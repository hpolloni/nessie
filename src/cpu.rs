use assert_matches::debug_assert_matches;
use std::{fmt::Display, ops::Add};

use bitflags::bitflags;

pub trait Bus {
    fn read(&self, address: u16) -> u8;
    fn write(&mut self, address: u16, value: u8);

    fn read16(&self, address: u16) -> u16 {
        let lo = u16::from(self.read(address));
        let hi = u16::from(self.read(address + 1));
        return (hi << 8) | lo;
    }
}

impl Bus for [u8; 65536] {
    fn read(&self, address: u16) -> u8 {
        self[address as usize]
    }

    fn write(&mut self, address: u16, value: u8) {
        self[address as usize] = value;
    }
}

#[derive(Debug, Clone, Copy)]
enum Address {
    Implied,
    Absolute(u16),
    Relative(u8),
}

impl Display for Address {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Absolute(address) => write!(f, "abs {:#04x}", address),
            Self::Relative(address) => write!(f, "rel {:#02x}", address),
            Self::Implied => write!(f, "implied"),
        }
    }
}

#[derive(Debug, Copy, Clone)]
struct OpCode {
    execute: fn(&mut CPU, Address),
    addressing: fn(&mut CPU) -> Address,
    name: &'static str,
    addr_name: &'static str,
    cycles: u8,
}

// Autogenerated from opcode_table_generator.py
static OPCODE_TABLE: [OpCode; 256] = [
    // Opcode: 0x00
    OpCode {
        execute: CPU::brk,
        addressing: CPU::implied,
        name: "BRK",
        addr_name: "IMP",
        cycles: 7,
    },
    // Opcode: 0x01
    OpCode {
        execute: CPU::ora,
        addressing: CPU::indirect_x,
        name: "ORA",
        addr_name: "IZX",
        cycles: 6,
    },
    // Opcode: 0x01
    OpCode {
        execute: CPU::ora,
        addressing: CPU::indirect_x,
        name: "ORA",
        addr_name: "IZX",
        cycles: 6,
    },
    // Opcode: 0x03
    OpCode {
        execute: CPU::slo,
        addressing: CPU::indirect_x,
        name: "SLO",
        addr_name: "IZX",
        cycles: 8,
    },
    // Opcode: 0x04
    OpCode {
        execute: CPU::nop,
        addressing: CPU::zero_page,
        name: "NOP",
        addr_name: "ZP",
        cycles: 3,
    },
    // Opcode: 0x05
    OpCode {
        execute: CPU::ora,
        addressing: CPU::zero_page,
        name: "ORA",
        addr_name: "ZP",
        cycles: 3,
    },
    // Opcode: 0x06
    OpCode {
        execute: CPU::asl,
        addressing: CPU::zero_page,
        name: "ASL",
        addr_name: "ZP",
        cycles: 5,
    },
    // Opcode: 0x07
    OpCode {
        execute: CPU::slo,
        addressing: CPU::zero_page,
        name: "SLO",
        addr_name: "ZP",
        cycles: 5,
    },
    // Opcode: 0x08
    OpCode {
        execute: CPU::php,
        addressing: CPU::implied,
        name: "PHP",
        addr_name: "IMP",
        cycles: 3,
    },
    // Opcode: 0x09
    OpCode {
        execute: CPU::ora,
        addressing: CPU::immediate,
        name: "ORA",
        addr_name: "IMM",
        cycles: 2,
    },
    // Opcode: 0x0A
    OpCode {
        execute: CPU::asl,
        addressing: CPU::implied,
        name: "ASL",
        addr_name: "IMP",
        cycles: 2,
    },
    // Opcode: 0x0B
    OpCode {
        execute: CPU::anc,
        addressing: CPU::immediate,
        name: "ANC",
        addr_name: "IMM",
        cycles: 2,
    },
    // Opcode: 0x0C
    OpCode {
        execute: CPU::nop,
        addressing: CPU::absolute,
        name: "NOP",
        addr_name: "ABS",
        cycles: 4,
    },
    // Opcode: 0x0D
    OpCode {
        execute: CPU::ora,
        addressing: CPU::absolute,
        name: "ORA",
        addr_name: "ABS",
        cycles: 4,
    },
    // Opcode: 0x0E
    OpCode {
        execute: CPU::asl,
        addressing: CPU::absolute,
        name: "ASL",
        addr_name: "ABS",
        cycles: 6,
    },
    // Opcode: 0x0F
    OpCode {
        execute: CPU::slo,
        addressing: CPU::absolute,
        name: "SLO",
        addr_name: "ABS",
        cycles: 6,
    },
    // Opcode: 0x10
    OpCode {
        execute: CPU::bpl,
        addressing: CPU::relative,
        name: "BPL",
        addr_name: "REL",
        cycles: 2,
    },
    // Opcode: 0x11
    OpCode {
        execute: CPU::ora,
        addressing: CPU::indirect_y,
        name: "ORA",
        addr_name: "IZY",
        cycles: 5,
    },
    // Opcode: 0x11
    OpCode {
        execute: CPU::ora,
        addressing: CPU::indirect_y,
        name: "ORA",
        addr_name: "IZY",
        cycles: 5,
    },
    // Opcode: 0x13
    OpCode {
        execute: CPU::slo,
        addressing: CPU::indirect_y,
        name: "SLO",
        addr_name: "IZY",
        cycles: 8,
    },
    // Opcode: 0x14
    OpCode {
        execute: CPU::nop,
        addressing: CPU::zero_page_x,
        name: "NOP",
        addr_name: "ZPX",
        cycles: 4,
    },
    // Opcode: 0x15
    OpCode {
        execute: CPU::ora,
        addressing: CPU::zero_page_x,
        name: "ORA",
        addr_name: "ZPX",
        cycles: 4,
    },
    // Opcode: 0x16
    OpCode {
        execute: CPU::asl,
        addressing: CPU::zero_page_x,
        name: "ASL",
        addr_name: "ZPX",
        cycles: 6,
    },
    // Opcode: 0x17
    OpCode {
        execute: CPU::slo,
        addressing: CPU::zero_page_x,
        name: "SLO",
        addr_name: "ZPX",
        cycles: 6,
    },
    // Opcode: 0x18
    OpCode {
        execute: CPU::clc,
        addressing: CPU::implied,
        name: "CLC",
        addr_name: "IMP",
        cycles: 2,
    },
    // Opcode: 0x19
    OpCode {
        execute: CPU::ora,
        addressing: CPU::absolute_y,
        name: "ORA",
        addr_name: "ABY",
        cycles: 4,
    },
    // Opcode: 0x1A
    OpCode {
        execute: CPU::nop,
        addressing: CPU::implied,
        name: "NOP",
        addr_name: "IMP",
        cycles: 2,
    },
    // Opcode: 0x1B
    OpCode {
        execute: CPU::slo,
        addressing: CPU::absolute_y,
        name: "SLO",
        addr_name: "ABY",
        cycles: 7,
    },
    // Opcode: 0x1C
    OpCode {
        execute: CPU::nop,
        addressing: CPU::absolute_x,
        name: "NOP",
        addr_name: "ABX",
        cycles: 4,
    },
    // Opcode: 0x1D
    OpCode {
        execute: CPU::ora,
        addressing: CPU::absolute_x,
        name: "ORA",
        addr_name: "ABX",
        cycles: 4,
    },
    // Opcode: 0x1E
    OpCode {
        execute: CPU::asl,
        addressing: CPU::absolute_x,
        name: "ASL",
        addr_name: "ABX",
        cycles: 7,
    },
    // Opcode: 0x1F
    OpCode {
        execute: CPU::slo,
        addressing: CPU::absolute_x,
        name: "SLO",
        addr_name: "ABX",
        cycles: 7,
    },
    // Opcode: 0x20
    OpCode {
        execute: CPU::jsr,
        addressing: CPU::absolute,
        name: "JSR",
        addr_name: "ABS",
        cycles: 6,
    },
    // Opcode: 0x21
    OpCode {
        execute: CPU::and,
        addressing: CPU::indirect_x,
        name: "AND",
        addr_name: "IZX",
        cycles: 6,
    },
    // Opcode: 0x21
    OpCode {
        execute: CPU::and,
        addressing: CPU::indirect_x,
        name: "AND",
        addr_name: "IZX",
        cycles: 6,
    },
    // Opcode: 0x23
    OpCode {
        execute: CPU::rla,
        addressing: CPU::indirect_x,
        name: "RLA",
        addr_name: "IZX",
        cycles: 8,
    },
    // Opcode: 0x24
    OpCode {
        execute: CPU::bit,
        addressing: CPU::zero_page,
        name: "BIT",
        addr_name: "ZP",
        cycles: 3,
    },
    // Opcode: 0x25
    OpCode {
        execute: CPU::and,
        addressing: CPU::zero_page,
        name: "AND",
        addr_name: "ZP",
        cycles: 3,
    },
    // Opcode: 0x26
    OpCode {
        execute: CPU::rol,
        addressing: CPU::zero_page,
        name: "ROL",
        addr_name: "ZP",
        cycles: 5,
    },
    // Opcode: 0x27
    OpCode {
        execute: CPU::rla,
        addressing: CPU::zero_page,
        name: "RLA",
        addr_name: "ZP",
        cycles: 5,
    },
    // Opcode: 0x28
    OpCode {
        execute: CPU::plp,
        addressing: CPU::implied,
        name: "PLP",
        addr_name: "IMP",
        cycles: 4,
    },
    // Opcode: 0x29
    OpCode {
        execute: CPU::and,
        addressing: CPU::immediate,
        name: "AND",
        addr_name: "IMM",
        cycles: 2,
    },
    // Opcode: 0x2A
    OpCode {
        execute: CPU::rol,
        addressing: CPU::implied,
        name: "ROL",
        addr_name: "IMP",
        cycles: 2,
    },
    // Opcode: 0x2B
    OpCode {
        execute: CPU::anc,
        addressing: CPU::immediate,
        name: "ANC",
        addr_name: "IMM",
        cycles: 2,
    },
    // Opcode: 0x2C
    OpCode {
        execute: CPU::bit,
        addressing: CPU::absolute,
        name: "BIT",
        addr_name: "ABS",
        cycles: 4,
    },
    // Opcode: 0x2D
    OpCode {
        execute: CPU::and,
        addressing: CPU::absolute,
        name: "AND",
        addr_name: "ABS",
        cycles: 4,
    },
    // Opcode: 0x2E
    OpCode {
        execute: CPU::rol,
        addressing: CPU::absolute,
        name: "ROL",
        addr_name: "ABS",
        cycles: 6,
    },
    // Opcode: 0x2F
    OpCode {
        execute: CPU::rla,
        addressing: CPU::absolute,
        name: "RLA",
        addr_name: "ABS",
        cycles: 6,
    },
    // Opcode: 0x30
    OpCode {
        execute: CPU::bmi,
        addressing: CPU::relative,
        name: "BMI",
        addr_name: "REL",
        cycles: 2,
    },
    // Opcode: 0x31
    OpCode {
        execute: CPU::and,
        addressing: CPU::indirect_y,
        name: "AND",
        addr_name: "IZY",
        cycles: 5,
    },
    // Opcode: 0x31
    OpCode {
        execute: CPU::and,
        addressing: CPU::indirect_y,
        name: "AND",
        addr_name: "IZY",
        cycles: 5,
    },
    // Opcode: 0x33
    OpCode {
        execute: CPU::rla,
        addressing: CPU::indirect_y,
        name: "RLA",
        addr_name: "IZY",
        cycles: 8,
    },
    // Opcode: 0x34
    OpCode {
        execute: CPU::nop,
        addressing: CPU::zero_page_x,
        name: "NOP",
        addr_name: "ZPX",
        cycles: 4,
    },
    // Opcode: 0x35
    OpCode {
        execute: CPU::and,
        addressing: CPU::zero_page_x,
        name: "AND",
        addr_name: "ZPX",
        cycles: 4,
    },
    // Opcode: 0x36
    OpCode {
        execute: CPU::rol,
        addressing: CPU::zero_page_x,
        name: "ROL",
        addr_name: "ZPX",
        cycles: 6,
    },
    // Opcode: 0x37
    OpCode {
        execute: CPU::rla,
        addressing: CPU::zero_page_x,
        name: "RLA",
        addr_name: "ZPX",
        cycles: 6,
    },
    // Opcode: 0x38
    OpCode {
        execute: CPU::sec,
        addressing: CPU::implied,
        name: "SEC",
        addr_name: "IMP",
        cycles: 2,
    },
    // Opcode: 0x39
    OpCode {
        execute: CPU::and,
        addressing: CPU::absolute_y,
        name: "AND",
        addr_name: "ABY",
        cycles: 4,
    },
    // Opcode: 0x3A
    OpCode {
        execute: CPU::nop,
        addressing: CPU::implied,
        name: "NOP",
        addr_name: "IMP",
        cycles: 2,
    },
    // Opcode: 0x3B
    OpCode {
        execute: CPU::rla,
        addressing: CPU::absolute_y,
        name: "RLA",
        addr_name: "ABY",
        cycles: 7,
    },
    // Opcode: 0x3C
    OpCode {
        execute: CPU::nop,
        addressing: CPU::absolute_x,
        name: "NOP",
        addr_name: "ABX",
        cycles: 4,
    },
    // Opcode: 0x3D
    OpCode {
        execute: CPU::and,
        addressing: CPU::absolute_x,
        name: "AND",
        addr_name: "ABX",
        cycles: 4,
    },
    // Opcode: 0x3E
    OpCode {
        execute: CPU::rol,
        addressing: CPU::absolute_x,
        name: "ROL",
        addr_name: "ABX",
        cycles: 7,
    },
    // Opcode: 0x3F
    OpCode {
        execute: CPU::rla,
        addressing: CPU::absolute_x,
        name: "RLA",
        addr_name: "ABX",
        cycles: 7,
    },
    // Opcode: 0x40
    OpCode {
        execute: CPU::rti,
        addressing: CPU::implied,
        name: "RTI",
        addr_name: "IMP",
        cycles: 6,
    },
    // Opcode: 0x41
    OpCode {
        execute: CPU::eor,
        addressing: CPU::indirect_x,
        name: "EOR",
        addr_name: "IZX",
        cycles: 6,
    },
    // Opcode: 0x41
    OpCode {
        execute: CPU::eor,
        addressing: CPU::indirect_x,
        name: "EOR",
        addr_name: "IZX",
        cycles: 6,
    },
    // Opcode: 0x43
    OpCode {
        execute: CPU::sre,
        addressing: CPU::indirect_x,
        name: "SRE",
        addr_name: "IZX",
        cycles: 8,
    },
    // Opcode: 0x44
    OpCode {
        execute: CPU::nop,
        addressing: CPU::zero_page,
        name: "NOP",
        addr_name: "ZP",
        cycles: 3,
    },
    // Opcode: 0x45
    OpCode {
        execute: CPU::eor,
        addressing: CPU::zero_page,
        name: "EOR",
        addr_name: "ZP",
        cycles: 3,
    },
    // Opcode: 0x46
    OpCode {
        execute: CPU::lsr,
        addressing: CPU::zero_page,
        name: "LSR",
        addr_name: "ZP",
        cycles: 5,
    },
    // Opcode: 0x47
    OpCode {
        execute: CPU::sre,
        addressing: CPU::zero_page,
        name: "SRE",
        addr_name: "ZP",
        cycles: 5,
    },
    // Opcode: 0x48
    OpCode {
        execute: CPU::pha,
        addressing: CPU::implied,
        name: "PHA",
        addr_name: "IMP",
        cycles: 3,
    },
    // Opcode: 0x49
    OpCode {
        execute: CPU::eor,
        addressing: CPU::immediate,
        name: "EOR",
        addr_name: "IMM",
        cycles: 2,
    },
    // Opcode: 0x4A
    OpCode {
        execute: CPU::lsr,
        addressing: CPU::implied,
        name: "LSR",
        addr_name: "IMP",
        cycles: 2,
    },
    // Opcode: 0x4B
    OpCode {
        execute: CPU::alr,
        addressing: CPU::immediate,
        name: "ALR",
        addr_name: "IMM",
        cycles: 2,
    },
    // Opcode: 0x4C
    OpCode {
        execute: CPU::jmp,
        addressing: CPU::absolute,
        name: "JMP",
        addr_name: "ABS",
        cycles: 3,
    },
    // Opcode: 0x4D
    OpCode {
        execute: CPU::eor,
        addressing: CPU::absolute,
        name: "EOR",
        addr_name: "ABS",
        cycles: 4,
    },
    // Opcode: 0x4E
    OpCode {
        execute: CPU::lsr,
        addressing: CPU::absolute,
        name: "LSR",
        addr_name: "ABS",
        cycles: 6,
    },
    // Opcode: 0x4F
    OpCode {
        execute: CPU::sre,
        addressing: CPU::absolute,
        name: "SRE",
        addr_name: "ABS",
        cycles: 6,
    },
    // Opcode: 0x50
    OpCode {
        execute: CPU::bvc,
        addressing: CPU::relative,
        name: "BVC",
        addr_name: "REL",
        cycles: 2,
    },
    // Opcode: 0x51
    OpCode {
        execute: CPU::eor,
        addressing: CPU::indirect_y,
        name: "EOR",
        addr_name: "IZY",
        cycles: 5,
    },
    // Opcode: 0x51
    OpCode {
        execute: CPU::eor,
        addressing: CPU::indirect_y,
        name: "EOR",
        addr_name: "IZY",
        cycles: 5,
    },
    // Opcode: 0x53
    OpCode {
        execute: CPU::sre,
        addressing: CPU::indirect_y,
        name: "SRE",
        addr_name: "IZY",
        cycles: 8,
    },
    // Opcode: 0x54
    OpCode {
        execute: CPU::nop,
        addressing: CPU::zero_page_x,
        name: "NOP",
        addr_name: "ZPX",
        cycles: 4,
    },
    // Opcode: 0x55
    OpCode {
        execute: CPU::eor,
        addressing: CPU::zero_page_x,
        name: "EOR",
        addr_name: "ZPX",
        cycles: 4,
    },
    // Opcode: 0x56
    OpCode {
        execute: CPU::lsr,
        addressing: CPU::zero_page_x,
        name: "LSR",
        addr_name: "ZPX",
        cycles: 6,
    },
    // Opcode: 0x57
    OpCode {
        execute: CPU::sre,
        addressing: CPU::zero_page_x,
        name: "SRE",
        addr_name: "ZPX",
        cycles: 6,
    },
    // Opcode: 0x58
    OpCode {
        execute: CPU::cli,
        addressing: CPU::implied,
        name: "CLI",
        addr_name: "IMP",
        cycles: 2,
    },
    // Opcode: 0x59
    OpCode {
        execute: CPU::eor,
        addressing: CPU::absolute_y,
        name: "EOR",
        addr_name: "ABY",
        cycles: 4,
    },
    // Opcode: 0x5A
    OpCode {
        execute: CPU::nop,
        addressing: CPU::implied,
        name: "NOP",
        addr_name: "IMP",
        cycles: 2,
    },
    // Opcode: 0x5B
    OpCode {
        execute: CPU::sre,
        addressing: CPU::absolute_y,
        name: "SRE",
        addr_name: "ABY",
        cycles: 7,
    },
    // Opcode: 0x5C
    OpCode {
        execute: CPU::nop,
        addressing: CPU::absolute_x,
        name: "NOP",
        addr_name: "ABX",
        cycles: 4,
    },
    // Opcode: 0x5D
    OpCode {
        execute: CPU::eor,
        addressing: CPU::absolute_x,
        name: "EOR",
        addr_name: "ABX",
        cycles: 4,
    },
    // Opcode: 0x5E
    OpCode {
        execute: CPU::lsr,
        addressing: CPU::absolute_x,
        name: "LSR",
        addr_name: "ABX",
        cycles: 7,
    },
    // Opcode: 0x5F
    OpCode {
        execute: CPU::sre,
        addressing: CPU::absolute_x,
        name: "SRE",
        addr_name: "ABX",
        cycles: 7,
    },
    // Opcode: 0x60
    OpCode {
        execute: CPU::rts,
        addressing: CPU::implied,
        name: "RTS",
        addr_name: "IMP",
        cycles: 6,
    },
    // Opcode: 0x61
    OpCode {
        execute: CPU::adc,
        addressing: CPU::indirect_x,
        name: "ADC",
        addr_name: "IZX",
        cycles: 6,
    },
    // Opcode: 0x61
    OpCode {
        execute: CPU::adc,
        addressing: CPU::indirect_x,
        name: "ADC",
        addr_name: "IZX",
        cycles: 6,
    },
    // Opcode: 0x63
    OpCode {
        execute: CPU::rra,
        addressing: CPU::indirect_x,
        name: "RRA",
        addr_name: "IZX",
        cycles: 8,
    },
    // Opcode: 0x64
    OpCode {
        execute: CPU::nop,
        addressing: CPU::zero_page,
        name: "NOP",
        addr_name: "ZP",
        cycles: 3,
    },
    // Opcode: 0x65
    OpCode {
        execute: CPU::adc,
        addressing: CPU::zero_page,
        name: "ADC",
        addr_name: "ZP",
        cycles: 3,
    },
    // Opcode: 0x66
    OpCode {
        execute: CPU::ror,
        addressing: CPU::zero_page,
        name: "ROR",
        addr_name: "ZP",
        cycles: 5,
    },
    // Opcode: 0x67
    OpCode {
        execute: CPU::rra,
        addressing: CPU::zero_page,
        name: "RRA",
        addr_name: "ZP",
        cycles: 5,
    },
    // Opcode: 0x68
    OpCode {
        execute: CPU::pla,
        addressing: CPU::implied,
        name: "PLA",
        addr_name: "IMP",
        cycles: 4,
    },
    // Opcode: 0x69
    OpCode {
        execute: CPU::adc,
        addressing: CPU::immediate,
        name: "ADC",
        addr_name: "IMM",
        cycles: 2,
    },
    // Opcode: 0x6A
    OpCode {
        execute: CPU::ror,
        addressing: CPU::implied,
        name: "ROR",
        addr_name: "IMP",
        cycles: 2,
    },
    // Opcode: 0x6B
    OpCode {
        execute: CPU::arr,
        addressing: CPU::immediate,
        name: "ARR",
        addr_name: "IMM",
        cycles: 2,
    },
    // Opcode: 0x6C
    OpCode {
        execute: CPU::jmp,
        addressing: CPU::indirect,
        name: "JMP",
        addr_name: "IND",
        cycles: 5,
    },
    // Opcode: 0x6D
    OpCode {
        execute: CPU::adc,
        addressing: CPU::absolute,
        name: "ADC",
        addr_name: "ABS",
        cycles: 4,
    },
    // Opcode: 0x6E
    OpCode {
        execute: CPU::ror,
        addressing: CPU::absolute,
        name: "ROR",
        addr_name: "ABS",
        cycles: 6,
    },
    // Opcode: 0x6F
    OpCode {
        execute: CPU::rra,
        addressing: CPU::absolute,
        name: "RRA",
        addr_name: "ABS",
        cycles: 6,
    },
    // Opcode: 0x70
    OpCode {
        execute: CPU::bvs,
        addressing: CPU::relative,
        name: "BVS",
        addr_name: "REL",
        cycles: 2,
    },
    // Opcode: 0x71
    OpCode {
        execute: CPU::adc,
        addressing: CPU::indirect_y,
        name: "ADC",
        addr_name: "IZY",
        cycles: 5,
    },
    // Opcode: 0x71
    OpCode {
        execute: CPU::adc,
        addressing: CPU::indirect_y,
        name: "ADC",
        addr_name: "IZY",
        cycles: 5,
    },
    // Opcode: 0x73
    OpCode {
        execute: CPU::rra,
        addressing: CPU::indirect_y,
        name: "RRA",
        addr_name: "IZY",
        cycles: 8,
    },
    // Opcode: 0x74
    OpCode {
        execute: CPU::nop,
        addressing: CPU::zero_page_x,
        name: "NOP",
        addr_name: "ZPX",
        cycles: 4,
    },
    // Opcode: 0x75
    OpCode {
        execute: CPU::adc,
        addressing: CPU::zero_page_x,
        name: "ADC",
        addr_name: "ZPX",
        cycles: 4,
    },
    // Opcode: 0x76
    OpCode {
        execute: CPU::ror,
        addressing: CPU::zero_page_x,
        name: "ROR",
        addr_name: "ZPX",
        cycles: 6,
    },
    // Opcode: 0x77
    OpCode {
        execute: CPU::rra,
        addressing: CPU::zero_page_x,
        name: "RRA",
        addr_name: "ZPX",
        cycles: 6,
    },
    // Opcode: 0x78
    OpCode {
        execute: CPU::sei,
        addressing: CPU::implied,
        name: "SEI",
        addr_name: "IMP",
        cycles: 2,
    },
    // Opcode: 0x79
    OpCode {
        execute: CPU::adc,
        addressing: CPU::absolute_y,
        name: "ADC",
        addr_name: "ABY",
        cycles: 4,
    },
    // Opcode: 0x7A
    OpCode {
        execute: CPU::nop,
        addressing: CPU::implied,
        name: "NOP",
        addr_name: "IMP",
        cycles: 2,
    },
    // Opcode: 0x7B
    OpCode {
        execute: CPU::rra,
        addressing: CPU::absolute_y,
        name: "RRA",
        addr_name: "ABY",
        cycles: 7,
    },
    // Opcode: 0x7C
    OpCode {
        execute: CPU::nop,
        addressing: CPU::absolute_x,
        name: "NOP",
        addr_name: "ABX",
        cycles: 4,
    },
    // Opcode: 0x7D
    OpCode {
        execute: CPU::adc,
        addressing: CPU::absolute_x,
        name: "ADC",
        addr_name: "ABX",
        cycles: 4,
    },
    // Opcode: 0x7E
    OpCode {
        execute: CPU::ror,
        addressing: CPU::absolute_x,
        name: "ROR",
        addr_name: "ABX",
        cycles: 7,
    },
    // Opcode: 0x7F
    OpCode {
        execute: CPU::rra,
        addressing: CPU::absolute_x,
        name: "RRA",
        addr_name: "ABX",
        cycles: 7,
    },
    // Opcode: 0x80
    OpCode {
        execute: CPU::nop,
        addressing: CPU::immediate,
        name: "NOP",
        addr_name: "IMM",
        cycles: 2,
    },
    // Opcode: 0x81
    OpCode {
        execute: CPU::sta,
        addressing: CPU::indirect_x,
        name: "STA",
        addr_name: "IZX",
        cycles: 6,
    },
    // Opcode: 0x82
    OpCode {
        execute: CPU::nop,
        addressing: CPU::immediate,
        name: "NOP",
        addr_name: "IMM",
        cycles: 2,
    },
    // Opcode: 0x83
    OpCode {
        execute: CPU::sax,
        addressing: CPU::indirect_x,
        name: "SAX",
        addr_name: "IZX",
        cycles: 6,
    },
    // Opcode: 0x84
    OpCode {
        execute: CPU::sty,
        addressing: CPU::zero_page,
        name: "STY",
        addr_name: "ZP",
        cycles: 3,
    },
    // Opcode: 0x85
    OpCode {
        execute: CPU::sta,
        addressing: CPU::zero_page,
        name: "STA",
        addr_name: "ZP",
        cycles: 3,
    },
    // Opcode: 0x86
    OpCode {
        execute: CPU::stx,
        addressing: CPU::zero_page,
        name: "STX",
        addr_name: "ZP",
        cycles: 3,
    },
    // Opcode: 0x87
    OpCode {
        execute: CPU::sax,
        addressing: CPU::zero_page,
        name: "SAX",
        addr_name: "ZP",
        cycles: 3,
    },
    // Opcode: 0x88
    OpCode {
        execute: CPU::dey,
        addressing: CPU::implied,
        name: "DEY",
        addr_name: "IMP",
        cycles: 2,
    },
    // Opcode: 0x89
    OpCode {
        execute: CPU::nop,
        addressing: CPU::immediate,
        name: "NOP",
        addr_name: "IMM",
        cycles: 2,
    },
    // Opcode: 0x8A
    OpCode {
        execute: CPU::txa,
        addressing: CPU::implied,
        name: "TXA",
        addr_name: "IMP",
        cycles: 2,
    },
    // Opcode: 0x8B
    OpCode {
        execute: CPU::xaa,
        addressing: CPU::immediate,
        name: "XAA",
        addr_name: "IMM",
        cycles: 2,
    },
    // Opcode: 0x8C
    OpCode {
        execute: CPU::sty,
        addressing: CPU::absolute,
        name: "STY",
        addr_name: "ABS",
        cycles: 4,
    },
    // Opcode: 0x8D
    OpCode {
        execute: CPU::sta,
        addressing: CPU::absolute,
        name: "STA",
        addr_name: "ABS",
        cycles: 4,
    },
    // Opcode: 0x8E
    OpCode {
        execute: CPU::stx,
        addressing: CPU::absolute,
        name: "STX",
        addr_name: "ABS",
        cycles: 4,
    },
    // Opcode: 0x8F
    OpCode {
        execute: CPU::sax,
        addressing: CPU::absolute,
        name: "SAX",
        addr_name: "ABS",
        cycles: 4,
    },
    // Opcode: 0x90
    OpCode {
        execute: CPU::bcc,
        addressing: CPU::relative,
        name: "BCC",
        addr_name: "REL",
        cycles: 2,
    },
    // Opcode: 0x91
    OpCode {
        execute: CPU::sta,
        addressing: CPU::indirect_y,
        name: "STA",
        addr_name: "IZY",
        cycles: 6,
    },
    // Opcode: 0x91
    OpCode {
        execute: CPU::sta,
        addressing: CPU::indirect_y,
        name: "STA",
        addr_name: "IZY",
        cycles: 6,
    },
    // Opcode: 0x93
    OpCode {
        execute: CPU::ahx,
        addressing: CPU::indirect_y,
        name: "AHX",
        addr_name: "IZY",
        cycles: 6,
    },
    // Opcode: 0x94
    OpCode {
        execute: CPU::sty,
        addressing: CPU::zero_page_x,
        name: "STY",
        addr_name: "ZPX",
        cycles: 4,
    },
    // Opcode: 0x95
    OpCode {
        execute: CPU::sta,
        addressing: CPU::zero_page_x,
        name: "STA",
        addr_name: "ZPX",
        cycles: 4,
    },
    // Opcode: 0x96
    OpCode {
        execute: CPU::stx,
        addressing: CPU::zero_page_y,
        name: "STX",
        addr_name: "ZPY",
        cycles: 4,
    },
    // Opcode: 0x97
    OpCode {
        execute: CPU::sax,
        addressing: CPU::zero_page_y,
        name: "SAX",
        addr_name: "ZPY",
        cycles: 4,
    },
    // Opcode: 0x98
    OpCode {
        execute: CPU::tya,
        addressing: CPU::implied,
        name: "TYA",
        addr_name: "IMP",
        cycles: 2,
    },
    // Opcode: 0x99
    OpCode {
        execute: CPU::sta,
        addressing: CPU::absolute_y,
        name: "STA",
        addr_name: "ABY",
        cycles: 5,
    },
    // Opcode: 0x9A
    OpCode {
        execute: CPU::txs,
        addressing: CPU::implied,
        name: "TXS",
        addr_name: "IMP",
        cycles: 2,
    },
    // Opcode: 0x9B
    OpCode {
        execute: CPU::tas,
        addressing: CPU::absolute_y,
        name: "TAS",
        addr_name: "ABY",
        cycles: 5,
    },
    // Opcode: 0x9C
    OpCode {
        execute: CPU::shy,
        addressing: CPU::absolute_x,
        name: "SHY",
        addr_name: "ABX",
        cycles: 5,
    },
    // Opcode: 0x9D
    OpCode {
        execute: CPU::sta,
        addressing: CPU::absolute_x,
        name: "STA",
        addr_name: "ABX",
        cycles: 5,
    },
    // Opcode: 0x9E
    OpCode {
        execute: CPU::shx,
        addressing: CPU::absolute_y,
        name: "SHX",
        addr_name: "ABY",
        cycles: 5,
    },
    // Opcode: 0x9F
    OpCode {
        execute: CPU::ahx,
        addressing: CPU::absolute_y,
        name: "AHX",
        addr_name: "ABY",
        cycles: 5,
    },
    // Opcode: 0xA0
    OpCode {
        execute: CPU::ldy,
        addressing: CPU::immediate,
        name: "LDY",
        addr_name: "IMM",
        cycles: 2,
    },
    // Opcode: 0xA1
    OpCode {
        execute: CPU::lda,
        addressing: CPU::indirect_x,
        name: "LDA",
        addr_name: "IZX",
        cycles: 6,
    },
    // Opcode: 0xA2
    OpCode {
        execute: CPU::ldx,
        addressing: CPU::immediate,
        name: "LDX",
        addr_name: "IMM",
        cycles: 2,
    },
    // Opcode: 0xA3
    OpCode {
        execute: CPU::lax,
        addressing: CPU::indirect_x,
        name: "LAX",
        addr_name: "IZX",
        cycles: 6,
    },
    // Opcode: 0xA4
    OpCode {
        execute: CPU::ldy,
        addressing: CPU::zero_page,
        name: "LDY",
        addr_name: "ZP",
        cycles: 3,
    },
    // Opcode: 0xA5
    OpCode {
        execute: CPU::lda,
        addressing: CPU::zero_page,
        name: "LDA",
        addr_name: "ZP",
        cycles: 3,
    },
    // Opcode: 0xA6
    OpCode {
        execute: CPU::ldx,
        addressing: CPU::zero_page,
        name: "LDX",
        addr_name: "ZP",
        cycles: 3,
    },
    // Opcode: 0xA7
    OpCode {
        execute: CPU::lax,
        addressing: CPU::zero_page,
        name: "LAX",
        addr_name: "ZP",
        cycles: 3,
    },
    // Opcode: 0xA8
    OpCode {
        execute: CPU::tay,
        addressing: CPU::implied,
        name: "TAY",
        addr_name: "IMP",
        cycles: 2,
    },
    // Opcode: 0xA9
    OpCode {
        execute: CPU::lda,
        addressing: CPU::immediate,
        name: "LDA",
        addr_name: "IMM",
        cycles: 2,
    },
    // Opcode: 0xAA
    OpCode {
        execute: CPU::tax,
        addressing: CPU::implied,
        name: "TAX",
        addr_name: "IMP",
        cycles: 2,
    },
    // Opcode: 0xAB
    OpCode {
        execute: CPU::lax,
        addressing: CPU::immediate,
        name: "LAX",
        addr_name: "IMM",
        cycles: 2,
    },
    // Opcode: 0xAC
    OpCode {
        execute: CPU::ldy,
        addressing: CPU::absolute,
        name: "LDY",
        addr_name: "ABS",
        cycles: 4,
    },
    // Opcode: 0xAD
    OpCode {
        execute: CPU::lda,
        addressing: CPU::absolute,
        name: "LDA",
        addr_name: "ABS",
        cycles: 4,
    },
    // Opcode: 0xAE
    OpCode {
        execute: CPU::ldx,
        addressing: CPU::absolute,
        name: "LDX",
        addr_name: "ABS",
        cycles: 4,
    },
    // Opcode: 0xAF
    OpCode {
        execute: CPU::lax,
        addressing: CPU::absolute,
        name: "LAX",
        addr_name: "ABS",
        cycles: 4,
    },
    // Opcode: 0xB0
    OpCode {
        execute: CPU::bcs,
        addressing: CPU::relative,
        name: "BCS",
        addr_name: "REL",
        cycles: 2,
    },
    // Opcode: 0xB1
    OpCode {
        execute: CPU::lda,
        addressing: CPU::indirect_y,
        name: "LDA",
        addr_name: "IZY",
        cycles: 5,
    },
    // Opcode: 0xB1
    OpCode {
        execute: CPU::lda,
        addressing: CPU::indirect_y,
        name: "LDA",
        addr_name: "IZY",
        cycles: 5,
    },
    // Opcode: 0xB3
    OpCode {
        execute: CPU::lax,
        addressing: CPU::indirect_y,
        name: "LAX",
        addr_name: "IZY",
        cycles: 5,
    },
    // Opcode: 0xB4
    OpCode {
        execute: CPU::ldy,
        addressing: CPU::zero_page_x,
        name: "LDY",
        addr_name: "ZPX",
        cycles: 4,
    },
    // Opcode: 0xB5
    OpCode {
        execute: CPU::lda,
        addressing: CPU::zero_page_x,
        name: "LDA",
        addr_name: "ZPX",
        cycles: 4,
    },
    // Opcode: 0xB6
    OpCode {
        execute: CPU::ldx,
        addressing: CPU::zero_page_y,
        name: "LDX",
        addr_name: "ZPY",
        cycles: 4,
    },
    // Opcode: 0xB7
    OpCode {
        execute: CPU::lax,
        addressing: CPU::zero_page_y,
        name: "LAX",
        addr_name: "ZPY",
        cycles: 4,
    },
    // Opcode: 0xB8
    OpCode {
        execute: CPU::clv,
        addressing: CPU::implied,
        name: "CLV",
        addr_name: "IMP",
        cycles: 2,
    },
    // Opcode: 0xB9
    OpCode {
        execute: CPU::lda,
        addressing: CPU::absolute_y,
        name: "LDA",
        addr_name: "ABY",
        cycles: 4,
    },
    // Opcode: 0xBA
    OpCode {
        execute: CPU::tsx,
        addressing: CPU::implied,
        name: "TSX",
        addr_name: "IMP",
        cycles: 2,
    },
    // Opcode: 0xBB
    OpCode {
        execute: CPU::las,
        addressing: CPU::absolute_y,
        name: "LAS",
        addr_name: "ABY",
        cycles: 4,
    },
    // Opcode: 0xBC
    OpCode {
        execute: CPU::ldy,
        addressing: CPU::absolute_x,
        name: "LDY",
        addr_name: "ABX",
        cycles: 4,
    },
    // Opcode: 0xBD
    OpCode {
        execute: CPU::lda,
        addressing: CPU::absolute_x,
        name: "LDA",
        addr_name: "ABX",
        cycles: 4,
    },
    // Opcode: 0xBE
    OpCode {
        execute: CPU::ldx,
        addressing: CPU::absolute_y,
        name: "LDX",
        addr_name: "ABY",
        cycles: 4,
    },
    // Opcode: 0xBF
    OpCode {
        execute: CPU::lax,
        addressing: CPU::absolute_y,
        name: "LAX",
        addr_name: "ABY",
        cycles: 4,
    },
    // Opcode: 0xC0
    OpCode {
        execute: CPU::cpy,
        addressing: CPU::immediate,
        name: "CPY",
        addr_name: "IMM",
        cycles: 2,
    },
    // Opcode: 0xC1
    OpCode {
        execute: CPU::cmp,
        addressing: CPU::indirect_x,
        name: "CMP",
        addr_name: "IZX",
        cycles: 6,
    },
    // Opcode: 0xC2
    OpCode {
        execute: CPU::nop,
        addressing: CPU::immediate,
        name: "NOP",
        addr_name: "IMM",
        cycles: 2,
    },
    // Opcode: 0xC3
    OpCode {
        execute: CPU::dcp,
        addressing: CPU::indirect_x,
        name: "DCP",
        addr_name: "IZX",
        cycles: 8,
    },
    // Opcode: 0xC4
    OpCode {
        execute: CPU::cpy,
        addressing: CPU::zero_page,
        name: "CPY",
        addr_name: "ZP",
        cycles: 3,
    },
    // Opcode: 0xC5
    OpCode {
        execute: CPU::cmp,
        addressing: CPU::zero_page,
        name: "CMP",
        addr_name: "ZP",
        cycles: 3,
    },
    // Opcode: 0xC6
    OpCode {
        execute: CPU::dec,
        addressing: CPU::zero_page,
        name: "DEC",
        addr_name: "ZP",
        cycles: 5,
    },
    // Opcode: 0xC7
    OpCode {
        execute: CPU::dcp,
        addressing: CPU::zero_page,
        name: "DCP",
        addr_name: "ZP",
        cycles: 5,
    },
    // Opcode: 0xC8
    OpCode {
        execute: CPU::iny,
        addressing: CPU::implied,
        name: "INY",
        addr_name: "IMP",
        cycles: 2,
    },
    // Opcode: 0xC9
    OpCode {
        execute: CPU::cmp,
        addressing: CPU::immediate,
        name: "CMP",
        addr_name: "IMM",
        cycles: 2,
    },
    // Opcode: 0xCA
    OpCode {
        execute: CPU::dex,
        addressing: CPU::implied,
        name: "DEX",
        addr_name: "IMP",
        cycles: 2,
    },
    // Opcode: 0xCB
    OpCode {
        execute: CPU::axs,
        addressing: CPU::immediate,
        name: "AXS",
        addr_name: "IMM",
        cycles: 2,
    },
    // Opcode: 0xCC
    OpCode {
        execute: CPU::cpy,
        addressing: CPU::absolute,
        name: "CPY",
        addr_name: "ABS",
        cycles: 4,
    },
    // Opcode: 0xCD
    OpCode {
        execute: CPU::cmp,
        addressing: CPU::absolute,
        name: "CMP",
        addr_name: "ABS",
        cycles: 4,
    },
    // Opcode: 0xCE
    OpCode {
        execute: CPU::dec,
        addressing: CPU::absolute,
        name: "DEC",
        addr_name: "ABS",
        cycles: 6,
    },
    // Opcode: 0xCF
    OpCode {
        execute: CPU::dcp,
        addressing: CPU::absolute,
        name: "DCP",
        addr_name: "ABS",
        cycles: 6,
    },
    // Opcode: 0xD0
    OpCode {
        execute: CPU::bne,
        addressing: CPU::relative,
        name: "BNE",
        addr_name: "REL",
        cycles: 2,
    },
    // Opcode: 0xD1
    OpCode {
        execute: CPU::cmp,
        addressing: CPU::indirect_y,
        name: "CMP",
        addr_name: "IZY",
        cycles: 5,
    },
    // Opcode: 0xD1
    OpCode {
        execute: CPU::cmp,
        addressing: CPU::indirect_y,
        name: "CMP",
        addr_name: "IZY",
        cycles: 5,
    },
    // Opcode: 0xD3
    OpCode {
        execute: CPU::dcp,
        addressing: CPU::indirect_y,
        name: "DCP",
        addr_name: "IZY",
        cycles: 8,
    },
    // Opcode: 0xD4
    OpCode {
        execute: CPU::nop,
        addressing: CPU::zero_page_x,
        name: "NOP",
        addr_name: "ZPX",
        cycles: 4,
    },
    // Opcode: 0xD5
    OpCode {
        execute: CPU::cmp,
        addressing: CPU::zero_page_x,
        name: "CMP",
        addr_name: "ZPX",
        cycles: 4,
    },
    // Opcode: 0xD6
    OpCode {
        execute: CPU::dec,
        addressing: CPU::zero_page_x,
        name: "DEC",
        addr_name: "ZPX",
        cycles: 6,
    },
    // Opcode: 0xD7
    OpCode {
        execute: CPU::dcp,
        addressing: CPU::zero_page_x,
        name: "DCP",
        addr_name: "ZPX",
        cycles: 6,
    },
    // Opcode: 0xD8
    OpCode {
        execute: CPU::cld,
        addressing: CPU::implied,
        name: "CLD",
        addr_name: "IMP",
        cycles: 2,
    },
    // Opcode: 0xD9
    OpCode {
        execute: CPU::cmp,
        addressing: CPU::absolute_y,
        name: "CMP",
        addr_name: "ABY",
        cycles: 4,
    },
    // Opcode: 0xDA
    OpCode {
        execute: CPU::nop,
        addressing: CPU::implied,
        name: "NOP",
        addr_name: "IMP",
        cycles: 2,
    },
    // Opcode: 0xDB
    OpCode {
        execute: CPU::dcp,
        addressing: CPU::absolute_y,
        name: "DCP",
        addr_name: "ABY",
        cycles: 7,
    },
    // Opcode: 0xDC
    OpCode {
        execute: CPU::nop,
        addressing: CPU::absolute_x,
        name: "NOP",
        addr_name: "ABX",
        cycles: 4,
    },
    // Opcode: 0xDD
    OpCode {
        execute: CPU::cmp,
        addressing: CPU::absolute_x,
        name: "CMP",
        addr_name: "ABX",
        cycles: 4,
    },
    // Opcode: 0xDE
    OpCode {
        execute: CPU::dec,
        addressing: CPU::absolute_x,
        name: "DEC",
        addr_name: "ABX",
        cycles: 7,
    },
    // Opcode: 0xDF
    OpCode {
        execute: CPU::dcp,
        addressing: CPU::absolute_x,
        name: "DCP",
        addr_name: "ABX",
        cycles: 7,
    },
    // Opcode: 0xE0
    OpCode {
        execute: CPU::cpx,
        addressing: CPU::immediate,
        name: "CPX",
        addr_name: "IMM",
        cycles: 2,
    },
    // Opcode: 0xE1
    OpCode {
        execute: CPU::sbc,
        addressing: CPU::indirect_x,
        name: "SBC",
        addr_name: "IZX",
        cycles: 6,
    },
    // Opcode: 0xE2
    OpCode {
        execute: CPU::nop,
        addressing: CPU::immediate,
        name: "NOP",
        addr_name: "IMM",
        cycles: 2,
    },
    // Opcode: 0xE3
    OpCode {
        execute: CPU::isc,
        addressing: CPU::indirect_x,
        name: "ISC",
        addr_name: "IZX",
        cycles: 8,
    },
    // Opcode: 0xE4
    OpCode {
        execute: CPU::cpx,
        addressing: CPU::zero_page,
        name: "CPX",
        addr_name: "ZP",
        cycles: 3,
    },
    // Opcode: 0xE5
    OpCode {
        execute: CPU::sbc,
        addressing: CPU::zero_page,
        name: "SBC",
        addr_name: "ZP",
        cycles: 3,
    },
    // Opcode: 0xE6
    OpCode {
        execute: CPU::inc,
        addressing: CPU::zero_page,
        name: "INC",
        addr_name: "ZP",
        cycles: 5,
    },
    // Opcode: 0xE7
    OpCode {
        execute: CPU::isc,
        addressing: CPU::zero_page,
        name: "ISC",
        addr_name: "ZP",
        cycles: 5,
    },
    // Opcode: 0xE8
    OpCode {
        execute: CPU::inx,
        addressing: CPU::implied,
        name: "INX",
        addr_name: "IMP",
        cycles: 2,
    },
    // Opcode: 0xE9
    OpCode {
        execute: CPU::sbc,
        addressing: CPU::immediate,
        name: "SBC",
        addr_name: "IMM",
        cycles: 2,
    },
    // Opcode: 0xEA
    OpCode {
        execute: CPU::nop,
        addressing: CPU::implied,
        name: "NOP",
        addr_name: "IMP",
        cycles: 2,
    },
    // Opcode: 0xEB
    OpCode {
        execute: CPU::sbc,
        addressing: CPU::immediate,
        name: "SBC",
        addr_name: "IMM",
        cycles: 2,
    },
    // Opcode: 0xEC
    OpCode {
        execute: CPU::cpx,
        addressing: CPU::absolute,
        name: "CPX",
        addr_name: "ABS",
        cycles: 4,
    },
    // Opcode: 0xED
    OpCode {
        execute: CPU::sbc,
        addressing: CPU::absolute,
        name: "SBC",
        addr_name: "ABS",
        cycles: 4,
    },
    // Opcode: 0xEE
    OpCode {
        execute: CPU::inc,
        addressing: CPU::absolute,
        name: "INC",
        addr_name: "ABS",
        cycles: 6,
    },
    // Opcode: 0xEF
    OpCode {
        execute: CPU::isc,
        addressing: CPU::absolute,
        name: "ISC",
        addr_name: "ABS",
        cycles: 6,
    },
    // Opcode: 0xF0
    OpCode {
        execute: CPU::beq,
        addressing: CPU::relative,
        name: "BEQ",
        addr_name: "REL",
        cycles: 2,
    },
    // Opcode: 0xF1
    OpCode {
        execute: CPU::sbc,
        addressing: CPU::indirect_y,
        name: "SBC",
        addr_name: "IZY",
        cycles: 5,
    },
    // Opcode: 0xF1
    OpCode {
        execute: CPU::sbc,
        addressing: CPU::indirect_y,
        name: "SBC",
        addr_name: "IZY",
        cycles: 5,
    },
    // Opcode: 0xF3
    OpCode {
        execute: CPU::isc,
        addressing: CPU::indirect_y,
        name: "ISC",
        addr_name: "IZY",
        cycles: 8,
    },
    // Opcode: 0xF4
    OpCode {
        execute: CPU::nop,
        addressing: CPU::zero_page_x,
        name: "NOP",
        addr_name: "ZPX",
        cycles: 4,
    },
    // Opcode: 0xF5
    OpCode {
        execute: CPU::sbc,
        addressing: CPU::zero_page_x,
        name: "SBC",
        addr_name: "ZPX",
        cycles: 4,
    },
    // Opcode: 0xF6
    OpCode {
        execute: CPU::inc,
        addressing: CPU::zero_page_x,
        name: "INC",
        addr_name: "ZPX",
        cycles: 6,
    },
    // Opcode: 0xF7
    OpCode {
        execute: CPU::isc,
        addressing: CPU::zero_page_x,
        name: "ISC",
        addr_name: "ZPX",
        cycles: 6,
    },
    // Opcode: 0xF8
    OpCode {
        execute: CPU::sed,
        addressing: CPU::implied,
        name: "SED",
        addr_name: "IMP",
        cycles: 2,
    },
    // Opcode: 0xF9
    OpCode {
        execute: CPU::sbc,
        addressing: CPU::absolute_y,
        name: "SBC",
        addr_name: "ABY",
        cycles: 4,
    },
    // Opcode: 0xFA
    OpCode {
        execute: CPU::nop,
        addressing: CPU::implied,
        name: "NOP",
        addr_name: "IMP",
        cycles: 2,
    },
    // Opcode: 0xFB
    OpCode {
        execute: CPU::isc,
        addressing: CPU::absolute_y,
        name: "ISC",
        addr_name: "ABY",
        cycles: 7,
    },
    // Opcode: 0xFC
    OpCode {
        execute: CPU::nop,
        addressing: CPU::absolute_x,
        name: "NOP",
        addr_name: "ABX",
        cycles: 4,
    },
    // Opcode: 0xFD
    OpCode {
        execute: CPU::sbc,
        addressing: CPU::absolute_x,
        name: "SBC",
        addr_name: "ABX",
        cycles: 4,
    },
    // Opcode: 0xFE
    OpCode {
        execute: CPU::inc,
        addressing: CPU::absolute_x,
        name: "INC",
        addr_name: "ABX",
        cycles: 7,
    },
    // Opcode: 0xFF
    OpCode {
        execute: CPU::isc,
        addressing: CPU::absolute_x,
        name: "ISC",
        addr_name: "ABX",
        cycles: 7,
    },
];

bitflags! {
    #[derive(Copy, Clone, Debug)]
    struct StatusFlags: u8 {
        const C = 1;
        const Z = 1 << 1;
        const I = 1 << 2;
        const D = 1 << 3;
        const B = 1 << 4;
        const X = 1 << 5;
        const O = 1 << 6;
        const N = 1 << 7;
    }
}

impl Display for StatusFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "[")?;
        self.write_if_contains(f, StatusFlags::C, "C")?;
        self.write_if_contains(f, StatusFlags::Z, "Z")?;
        self.write_if_contains(f, StatusFlags::I, "I")?;
        self.write_if_contains(f, StatusFlags::D, "D")?;
        self.write_if_contains(f, StatusFlags::B, "B")?;
        self.write_if_contains(f, StatusFlags::X, "X")?;
        self.write_if_contains(f, StatusFlags::O, "O")?;
        self.write_if_contains(f, StatusFlags::N, "N")?;
        write!(f, "]")
    }
}

impl StatusFlags {
    fn write_if_contains(
        &self,
        f: &mut std::fmt::Formatter<'_>,
        flag: StatusFlags,
        name: &str,
    ) -> std::fmt::Result {
        if self.contains(flag) {
            write!(f, "{}", name)?
        }
        Ok(())
    }
}

pub struct CPU {
    accumulator: u8,
    x_register: u8,
    y_register: u8,
    program_counter: u16,
    remaining_cycles: u8,
    bus: Box<dyn Bus>,
    status: StatusFlags,
    total_cycles: u16,
    stack_pointer: u8,
}

impl CPU {
    pub fn new(pc: u16, bus: Box<dyn Bus>) -> Self {
        Self {
            accumulator: 0x00,
            x_register: 0x00,
            y_register: 0x00,
            program_counter: pc,
            remaining_cycles: 0,
            total_cycles: 0,
            stack_pointer: 0xfd,
            bus,
            status: StatusFlags::from_bits_truncate(0x24),
        }
    }

    fn cycle(&mut self) {
        if self.remaining_cycles == 0 {
            let opcode = self.bus.read(self.program_counter);

            self.program_counter += 1;

            let op = OPCODE_TABLE[opcode as usize];

            let address = (op.addressing)(self);

            (op.execute)(self, address);

            self.remaining_cycles += op.cycles;
        }
        self.total_cycles += 1;
        self.remaining_cycles -= 1;
    }

    pub fn step(&mut self) {
        self.cycle();
        while self.remaining_cycles != 0 {
            self.cycle();
        }
    }

    pub fn run_until_brk(&mut self) {
        while !self.status.contains(StatusFlags::B) {
            self.step()
        }
    }

    fn set_zero_or_neg_flags(&mut self, value: u8) {
        self.status.set(StatusFlags::Z, value == 0);
        self.status
            .set(StatusFlags::N, value & StatusFlags::N.bits() != 0);
    }
}

fn s8_to_u16(value: u8) -> u16 {
    let mut value = u16::from(value);
    if value & 0x80 > 0 {
        value |= 0xff00;
    }
    return value;
}

const STACK_PAGE: u16 = 0x0100;

// Operations
impl CPU {
    fn adc(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Absolute(address) => {
            let value = self.bus.read(address);
            let carry = self.status.contains(StatusFlags::C) as u16;
            let result: u16 = u16::from(self.accumulator) + u16::from(value) + carry;
            let result_u8 = result as u8;

            self.status.set(StatusFlags::C, result > u16::from(u8::max_value()));
            self.status.set(
                StatusFlags::O,
                (!(self.accumulator ^ value)
                    & (self.accumulator ^ result_u8)
                    & StatusFlags::N.bits())
                    > 0,
            );
            self.set_zero_or_neg_flags(result_u8);

            self.accumulator = result_u8;
        });
    }

    fn ahx(&mut self, _address: Address) {
        todo!("ahx Not Implemented")
    }

    fn alr(&mut self, _address: Address) {
        todo!("alr Not Implemented")
    }

    fn anc(&mut self, _address: Address) {
        todo!("anc Not Implemented")
    }

    fn and(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Absolute(address) => {
            let value = self.bus.read(address);
            self.accumulator &= value;
            self.set_zero_or_neg_flags(self.accumulator);
        });
    }

    fn arr(&mut self, _address: Address) {
        todo!("arr Not Implemented")
    }

    fn asl(&mut self, _address: Address) {
        todo!("asl Not Implemented")
    }

    fn axs(&mut self, _address: Address) {
        todo!("axs Not Implemented")
    }

    fn branch(&mut self, address: Address, cond: bool) {
        debug_assert_matches!(address,
        Address::Relative(address) => {
            let address = s8_to_u16(address).wrapping_add(self.program_counter);

            if cond {
                if address & 0xff00 != self.program_counter & 0xff00 {
                    self.remaining_cycles += 2;
                } else {
                    self.remaining_cycles += 1;
                }
                self.program_counter = address;
            }
        });
    }

    fn bcc(&mut self, address: Address) {
        self.branch(address, !self.status.contains(StatusFlags::C));
    }

    fn bcs(&mut self, address: Address) {
        self.branch(address, self.status.contains(StatusFlags::C));
    }

    fn beq(&mut self, address: Address) {
        self.branch(address, self.status.contains(StatusFlags::Z));
    }

    fn bit(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Absolute(address) => {
            let value = self.bus.read(address);
            let mask = StatusFlags::from_bits_truncate(value);

            self.status.set(StatusFlags::Z, self.accumulator & value == 0);
            self.status.set(StatusFlags::O, mask.contains(StatusFlags::O));
            self.status.set(StatusFlags::N, mask.contains(StatusFlags::N));
        });
    }

    fn bmi(&mut self, address: Address) {
        self.branch(address, self.status.contains(StatusFlags::N));
    }

    fn bne(&mut self, address: Address) {
        self.branch(address, !self.status.contains(StatusFlags::Z));
    }

    fn bpl(&mut self, address: Address) {
        self.branch(address, !self.status.contains(StatusFlags::N));
    }

    fn brk(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Implied);

        self.status |= StatusFlags::B;
        // TODO: stack manipulation
    }

    fn bvc(&mut self, address: Address) {
        self.branch(address, !self.status.contains(StatusFlags::O));
    }

    fn bvs(&mut self, address: Address) {
        self.branch(address, self.status.contains(StatusFlags::O));
    }

    fn clc(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Implied);
        self.status -= StatusFlags::C;
    }

    fn cld(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Implied);

        self.status -= StatusFlags::D;
    }

    fn cli(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Implied);

        self.status -= StatusFlags::I;
    }

    fn clv(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Implied);

        self.status -= StatusFlags::O;
    }

    fn compare(&mut self, address: Address, register_value: u8) {
        debug_assert_matches!(address, Address::Absolute(address) => {
            let value = self.bus.read(address);

            self.status.set(StatusFlags::C, register_value >= value);

            let cmp = register_value.wrapping_sub(value);
            self.set_zero_or_neg_flags(cmp);
        });
    }

    fn cmp(&mut self, address: Address) {
        self.compare(address, self.accumulator);
    }

    fn cpx(&mut self, address: Address) {
        self.compare(address, self.x_register);
    }

    fn cpy(&mut self, address: Address) {
        self.compare(address, self.y_register);
    }

    fn dcp(&mut self, _address: Address) {
        todo!("dcp Not Implemented")
    }

    fn dec(&mut self, _address: Address) {
        todo!("dec Not Implemented")
    }

    fn dex(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Implied);

        self.x_register = self.x_register.wrapping_sub(1);
        self.set_zero_or_neg_flags(self.x_register);
    }

    fn dey(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Implied);

        self.y_register = self.y_register.wrapping_sub(1);
        self.set_zero_or_neg_flags(self.y_register);
    }

    fn eor(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Absolute(address) => {
            let value = self.bus.read(address);
            self.accumulator ^= value;
            self.set_zero_or_neg_flags(self.accumulator);
        });
    }

    fn inc(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Absolute(address) => {
            let value = self.bus.read(address).wrapping_add(1);
            self.set_zero_or_neg_flags(value);
            self.bus.write(address, value);
        });
    }

    fn inx(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Implied);

        self.x_register = self.x_register.wrapping_add(1);
        self.set_zero_or_neg_flags(self.x_register);
    }

    fn iny(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Implied);

        self.y_register = self.y_register.wrapping_add(1);
        self.set_zero_or_neg_flags(self.y_register);
    }

    fn isc(&mut self, _address: Address) {
        todo!("isc Not Implemented")
    }

    fn jmp(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Absolute(address) => self.program_counter = address);
    }

    fn jsr(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Absolute(address) => {
            self.push_stack_16(self.program_counter - 1);
            self.program_counter = address;
        });
    }

    fn las(&mut self, _address: Address) {
        todo!("las Not Implemented")
    }

    fn lax(&mut self, _address: Address) {
        todo!("lax Not Implemented")
    }

    fn lda(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Absolute(address) => {
            self.accumulator = self.bus.read(address);
            self.set_zero_or_neg_flags(self.accumulator);
        });
    }

    fn ldx(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Absolute(address) => {
            self.x_register = self.bus.read(address);
            self.set_zero_or_neg_flags(self.x_register);
        });
    }

    fn ldy(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Absolute(address) => {
            self.y_register = self.bus.read(address);
            self.set_zero_or_neg_flags(self.y_register);
        });
    }

    fn lsr(&mut self, address: Address) {
        let mut inner = |value: u8| -> u8 {
            self.status.set(StatusFlags::C, value & 1 == 1);
            let shifted_value = value >> 1;
            self.status.set(StatusFlags::Z, shifted_value == 0);
            self.status.set(StatusFlags::N, false);
            return shifted_value;
        };

        match address {
            Address::Implied => self.accumulator = inner(self.accumulator),
            Address::Absolute(address) => {
                let value = inner(self.bus.read(address));
                self.bus.write(address, value);
            }
            _ => panic!("LSR opcode with relative addressing"),
        }
    }

    fn nop(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Implied);

        // Do nothing (NOP)
    }

    fn ora(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Absolute(address) => {
            let value = self.bus.read(address);
            self.accumulator |= value;
            self.set_zero_or_neg_flags(self.accumulator);
        });
    }

    fn pha(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Implied);

        self.push_stack(self.accumulator);
    }

    fn php(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Implied);

        self.push_stack((self.status | StatusFlags::B).bits());
    }

    fn pla(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Implied);

        self.accumulator = self.pop_stack();
        self.set_zero_or_neg_flags(self.accumulator);
    }

    fn plp(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Implied);

        let old_status = self.status;
        let mut new_status = StatusFlags::from_bits_truncate(self.pop_stack());

        // TODO: simplify

        new_status.set(StatusFlags::B, old_status.contains(StatusFlags::B));
        new_status.set(StatusFlags::X, old_status.contains(StatusFlags::X));

        self.status = new_status;
    }

    fn rla(&mut self, _address: Address) {
        todo!("rla Not Implemented")
    }

    fn rol(&mut self, _address: Address) {
        todo!("rol Not Implemented")
    }

    fn ror(&mut self, _address: Address) {
        todo!("ror Not Implemented")
    }

    fn rra(&mut self, _address: Address) {
        todo!("rra Not Implemented")
    }

    fn rti(&mut self, address: Address) {
        self.plp(address);
        self.program_counter = self.pop_stack_16();
    }

    fn rts(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Implied);

        self.program_counter = self.pop_stack_16() + 1;
    }

    fn sax(&mut self, _address: Address) {
        todo!("sax Not Implemented")
    }

    fn sbc(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Absolute(address) => {
            let value = self.bus.read(address);
            let carry = self.status.contains(StatusFlags::C) as u16;

            let result = u16::from(self.accumulator) + u16::from(!value) + carry;

            let result_u8 = result as u8;

            self.status.set(StatusFlags::C, result > u16::from(u8::max_value()));
            self.status.set(StatusFlags::Z, result_u8 == 0);
            self.status.set(
                StatusFlags::O,
                ((self.accumulator ^ value)
                    & (self.accumulator ^ result_u8)
                    & StatusFlags::N.bits())
                    > 0,
            );

            self.status.set(StatusFlags::N, result_u8 & StatusFlags::N.bits() > 0);

            self.accumulator = result_u8;
        });
    }

    fn sec(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Implied);

        self.status |= StatusFlags::C;
    }

    fn sed(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Implied);

        self.status |= StatusFlags::D;
    }

    fn sei(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Implied);

        self.status |= StatusFlags::I;
    }

    fn shx(&mut self, _address: Address) {
        todo!("shx Not Implemented")
    }

    fn shy(&mut self, _address: Address) {
        todo!("shy Not Implemented")
    }

    fn slo(&mut self, _address: Address) {
        todo!("slo Not Implemented")
    }

    fn sre(&mut self, _address: Address) {
        todo!("sre Not Implemented")
    }

    fn sta(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Absolute(address) => self.bus.write(address, self.accumulator));
    }

    fn stx(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Absolute(address) => self.bus.write(address, self.x_register));
    }

    fn sty(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Absolute(address) => self.bus.write(address, self.y_register));
    }

    fn tas(&mut self, _address: Address) {
        todo!("tas Not Implemented")
    }

    fn tax(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Implied);

        self.x_register = self.accumulator;

        self.set_zero_or_neg_flags(self.x_register);
    }

    fn tay(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Implied);

        self.y_register = self.accumulator;

        self.set_zero_or_neg_flags(self.y_register);
    }

    fn tsx(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Implied);

        self.x_register = self.stack_pointer;
        self.set_zero_or_neg_flags(self.x_register);
    }

    fn txa(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Implied);

        self.accumulator = self.x_register;
        self.set_zero_or_neg_flags(self.x_register);
    }

    fn txs(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Implied);

        self.stack_pointer = self.x_register;
    }

    fn tya(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Implied);

        self.accumulator = self.y_register;
        self.set_zero_or_neg_flags(self.y_register);
    }

    fn xaa(&mut self, _address: Address) {
        todo!("xaa Not Implemented")
    }
}

// Stack manipulation functions
impl CPU {
    fn pop_stack(&mut self) -> u8 {
        self.stack_pointer = self.stack_pointer.wrapping_add(1);
        self.bus.read(STACK_PAGE + u16::from(self.stack_pointer))
    }

    fn pop_stack_16(&mut self) -> u16 {
        let lo = u16::from(self.pop_stack());
        let hi = u16::from(self.pop_stack());
        return (hi << 8) | lo;
    }

    fn push_stack_16(&mut self, data: u16) {
        self.push_stack((data >> 8) as u8);
        self.push_stack(data as u8);
    }

    fn push_stack(&mut self, data: u8) {
        self.bus
            .write(STACK_PAGE + u16::from(self.stack_pointer), data);
        self.stack_pointer = self.stack_pointer.wrapping_sub(1);
    }
}

// Addressing modes
impl CPU {
    fn implied(&mut self) -> Address {
        Address::Implied
    }

    fn immediate(&mut self) -> Address {
        let address = self.program_counter;
        self.program_counter += 1;

        Address::Absolute(address)
    }

    fn zero_page(&mut self) -> Address {
        let address = u16::from(self.bus.read(self.program_counter));
        self.program_counter += 1;
        Address::Absolute(address)
    }

    fn zero_page_x(&mut self) -> Address {
        todo!()
    }

    fn zero_page_y(&mut self) -> Address {
        todo!()
    }

    fn absolute(&mut self) -> Address {
        let address = self.bus.read16(self.program_counter);
        self.program_counter += 2;
        Address::Absolute(address)
    }

    fn absolute_x(&mut self) -> Address {
        let address: u16 = self.bus.read16(self.program_counter);
        let offset_address: u16 = address + u16::from(self.x_register);

        self.remaining_cycles += if (offset_address) & 0xff00 != address & 0xff00 {
            // Extra time for crossing a page boundary
            1
        } else {
            0
        };

        self.program_counter += 2;
        Address::Absolute(offset_address)
    }

    fn absolute_y(&mut self) -> Address {
        todo!("absolute_y")
    }

    fn indirect(&mut self) -> Address {
        todo!("indirect")
    }

    fn indirect_x(&mut self) -> Address {
        let indirect_address = self.bus.read(self.program_counter);

        // Simulate bug at page edge
        let address = ((self.bus.read(
            indirect_address
                .wrapping_add(self.x_register)
                .wrapping_add(1) as u16,
        ) as u16)
            << 8)
            | self
                .bus
                .read(indirect_address.wrapping_add(self.x_register) as u16) as u16;

        self.program_counter += 1;
        Address::Absolute(address)
    }

    fn indirect_y(&mut self) -> Address {
        todo!("indirect_y")
    }

    fn relative(&mut self) -> Address {
        let relative_address = self.bus.read(self.program_counter);
        self.program_counter += 1;
        Address::Relative(relative_address)
    }
}

impl Display for CPU {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "{:#04X} A:{:#04X} X:{:#04X} Y:{:#04X} P:{:#04X} SP:{:#04X}",
            self.program_counter,
            self.accumulator,
            self.x_register,
            self.y_register,
            self.status.bits(),
            self.stack_pointer
        )
    }
}

#[cfg(test)]
mod tests {
    use std::{fmt::Display, fs::File, io::Read};

    use super::CPU;

    #[test]
    fn test_simple_program() {
        let program = [
            0xa9, 0x10, // LDA #$10     -> A = #$10
            0x85, 0x20, // STA $20      -> $20 = #$10
            0xa9, 0x01, // LDA #$1      -> A = #$1
            0x65, 0x20, // ADC $20      -> A = #$11
            0x85, 0x21, // STA $21      -> $21=#$11
            0xe6, 0x21, // INC $21      -> $21=#$12
            0xa4, 0x21, // LDY $21      -> Y=#$12
            0xc8, // INY          -> Y=#$13
            0x00, // BRK
        ];

        let mut ram = [0u8; 65536];
        ram[0x0000..program.len()].copy_from_slice(&program);

        let mut cpu = CPU::new(0x00, Box::new(ram));

        // LDA #$10
        cpu.step();

        assert_eq!(cpu.accumulator, 0x10);

        // STA $20
        cpu.step();

        assert_eq!(cpu.bus.read(0x20), 0x10);

        // LDA #$1
        cpu.step();
        assert_eq!(cpu.accumulator, 0x01);

        // ADC $20
        cpu.step();
        assert_eq!(cpu.accumulator, 0x11);

        // STA $21
        cpu.step();
        assert_eq!(cpu.bus.read(0x21), 0x11);

        // INC $21
        cpu.step();
        assert_eq!(cpu.bus.read(0x21), 0x12);

        // LDY $21
        cpu.step();
        assert_eq!(cpu.y_register, 0x12);

        // INY
        cpu.step();
        assert_eq!(cpu.y_register, 0x13);
    }

    #[test]
    fn test_euclid_algo() {
        // From https://github.com/mre/mos6502/blob/master/examples/asm/euclid/euclid.a65
        let program = [
            // .algo
            0xa5, 0x00, // LDA $00
            // .algo_
            0x38, // SEC
            0xe5, 0x01, // SBC $01
            0xf0, 0x07, // BEQ end
            0x30, 0x08, // BMI swap
            0x85, 0x00, // STA $00
            0x4c, 0x12, 0x00, // JMP algo_
            // .end
            0xa5, 0x00, // LDA $00
            0x00, // .swap
            0xa6, 0x00, // LDX $00
            0xa4, 0x01, // LDY $01
            0x86, 0x01, // STX $01
            0x84, 0x00, // STY $00
            0x4c, 0x10, 0x00, // JMP algo
        ];

        let mut ram = [0u8; 65536];
        ram[0x00] = 30;
        ram[0x01] = 20;
        ram[0x10..0x10 + program.len()].copy_from_slice(&program);

        let mut cpu = CPU::new(0x10, Box::new(ram));

        cpu.run_until_brk();

        assert_eq!(10, cpu.accumulator);
    }

    #[derive(Debug)]
    struct CpuState {
        program_counter: u16,
        total_cycles: u16,
        accumulator: u8,
        x_register: u8,
        y_register: u8,
        status: u8,
        stack_pointer: u8,
    }

    impl Display for CpuState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(
                f,
                "{:#04X} A:{:#04X} X:{:#04X} Y:{:#04X} P:{:#04X} SP:{:#04X}",
                self.program_counter,
                self.accumulator,
                self.x_register,
                self.y_register,
                self.status,
                self.stack_pointer
            )
        }
    }

    fn parse_nestest_output(fname: &str) -> Result<Vec<CpuState>, Box<dyn std::error::Error>> {
        let mut file = File::open(fname).unwrap();
        let mut content: String = String::new();
        file.read_to_string(&mut content).unwrap();

        let mut cpu_states = vec![];
        for line in content.lines() {
            // Skip empty lines and comments
            if !line.is_empty() && !line.starts_with("#") {
                let program_counter = u16::from_str_radix(&line[0..4], 16)?;
                let accumulator = u8::from_str_radix(&line[50..52].trim(), 16)?;
                let x_register = u8::from_str_radix(&line[55..57].trim(), 16)?;
                let y_register = u8::from_str_radix(&line[60..62].trim(), 16)?;
                let status = u8::from_str_radix(&line[65..67].trim(), 16)?;
                let stack_pointer = u8::from_str_radix(&line[71..73].trim(), 16)?;

                let total_cycles = &line[90..].trim().parse::<u16>()?;

                // TODO: Figure out why nestest start at 7 total cycles instead of 0
                let total_cycles = total_cycles - 7;

                cpu_states.push(CpuState {
                    program_counter,
                    accumulator,
                    total_cycles,
                    x_register,
                    y_register,
                    status,
                    stack_pointer,
                });
            }
        }
        Ok(cpu_states)
    }

    #[test]
    fn test_nestest_rom() -> Result<(), Box<dyn std::error::Error>> {
        let mut file = File::open("roms/nestest/nestest.nes")?;
        let expected_cpu_states = parse_nestest_output("roms/nestest/nestest.expected.out")?;

        let mut buffer = Vec::new();
        file.read_to_end(&mut buffer).unwrap();

        let mut ram = [0u8; 65536];

        ram[0x8000..0xBFFF].copy_from_slice(&buffer[0x0010..0x400f]);
        ram[0xC000..0xFFFF].copy_from_slice(&buffer[0x0010..0x400f]);

        let mut cpu = CPU::new(0xC000, Box::new(ram));

        println!("Expected                                        | Actual");
        println!(
            "--------------------------------------------------------------------------------------------"
        );

        let mut step = 1;
        for expected_cpu_state in expected_cpu_states {
            println!("{:#04} {} | {}", step, expected_cpu_state, cpu);

            assert_eq!(expected_cpu_state.program_counter, cpu.program_counter);
            assert_eq!(expected_cpu_state.total_cycles, cpu.total_cycles);
            assert_eq!(expected_cpu_state.x_register, cpu.x_register);
            assert_eq!(expected_cpu_state.y_register, cpu.y_register);
            assert_eq!(expected_cpu_state.status, cpu.status.bits());
            assert_eq!(expected_cpu_state.stack_pointer, cpu.stack_pointer);

            cpu.step();
            step += 1;
        }

        Ok(())
    }
}
