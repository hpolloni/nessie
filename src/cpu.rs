use assert_matches::debug_assert_matches;

use bitflags::bitflags;

use crate::bus::Bus;

#[derive(Debug, Clone, Copy)]
enum Address {
    Implied,
    Absolute(u16),
    Relative(u8),
}

#[derive(Debug, Copy, Clone)]
enum AddressingMode {
    Absolute,
    AbsoluteX,
    AbsoluteY,
    Implied,
    Immediate,
    ZeroPage,
    ZeroPageX,
    ZeroPageY,
    Relative,
    IndirectX,
    IndirectY,
    Indirect,
}

#[derive(Debug, Copy, Clone)]
struct OpCode {
    execute: fn(&mut CPU, Address),
    addressing: fn(&CPU) -> Address,
    name: &'static str,
    addressing_mode: AddressingMode,
    cycles: u8,
}

impl OpCode {
    fn len(&self) -> u16 {
        match self.addressing_mode {
            AddressingMode::Absolute
            | AddressingMode::AbsoluteY
            | AddressingMode::AbsoluteX
            | AddressingMode::Indirect => 3,

            AddressingMode::Immediate
            | AddressingMode::ZeroPage
            | AddressingMode::ZeroPageX
            | AddressingMode::Relative
            | AddressingMode::IndirectX
            | AddressingMode::IndirectY
            | AddressingMode::ZeroPageY => 2,

            AddressingMode::Implied => 1,
        }
    }
}

// Autogenerated from opcode_table_generator.py
static OPCODE_TABLE: [OpCode; 256] = [
    // Opcode: 0x00
    OpCode {
        execute: CPU::brk,
        addressing: CPU::implied,
        name: "BRK",
        addressing_mode: AddressingMode::Implied,
        cycles: 7,
    },
    // Opcode: 0x01
    OpCode {
        execute: CPU::ora,
        addressing: CPU::indirect_x,
        name: "ORA",
        addressing_mode: AddressingMode::IndirectX,
        cycles: 6,
    },
    // Opcode: 0x01
    OpCode {
        execute: CPU::ora,
        addressing: CPU::indirect_x,
        name: "ORA",
        addressing_mode: AddressingMode::IndirectX,
        cycles: 6,
    },
    // Opcode: 0x03
    OpCode {
        execute: CPU::slo,
        addressing: CPU::indirect_x,
        name: "SLO",
        addressing_mode: AddressingMode::IndirectX,
        cycles: 8,
    },
    // Opcode: 0x04
    OpCode {
        execute: CPU::nop,
        addressing: CPU::zero_page,
        name: "NOP",
        addressing_mode: AddressingMode::ZeroPage,
        cycles: 3,
    },
    // Opcode: 0x05
    OpCode {
        execute: CPU::ora,
        addressing: CPU::zero_page,
        name: "ORA",
        addressing_mode: AddressingMode::ZeroPage,
        cycles: 3,
    },
    // Opcode: 0x06
    OpCode {
        execute: CPU::asl,
        addressing: CPU::zero_page,
        name: "ASL",
        addressing_mode: AddressingMode::ZeroPage,
        cycles: 5,
    },
    // Opcode: 0x07
    OpCode {
        execute: CPU::slo,
        addressing: CPU::zero_page,
        name: "SLO",
        addressing_mode: AddressingMode::ZeroPage,
        cycles: 5,
    },
    // Opcode: 0x08
    OpCode {
        execute: CPU::php,
        addressing: CPU::implied,
        name: "PHP",
        addressing_mode: AddressingMode::Implied,
        cycles: 3,
    },
    // Opcode: 0x09
    OpCode {
        execute: CPU::ora,
        addressing: CPU::immediate,
        name: "ORA",
        addressing_mode: AddressingMode::Immediate,
        cycles: 2,
    },
    // Opcode: 0x0A
    OpCode {
        execute: CPU::asl,
        addressing: CPU::implied,
        name: "ASL",
        addressing_mode: AddressingMode::Implied,
        cycles: 2,
    },
    // Opcode: 0x0B
    OpCode {
        execute: CPU::anc,
        addressing: CPU::immediate,
        name: "ANC",
        addressing_mode: AddressingMode::Immediate,
        cycles: 2,
    },
    // Opcode: 0x0C
    OpCode {
        execute: CPU::nop,
        addressing: CPU::absolute,
        name: "NOP",
        addressing_mode: AddressingMode::Absolute,
        cycles: 4,
    },
    // Opcode: 0x0D
    OpCode {
        execute: CPU::ora,
        addressing: CPU::absolute,
        name: "ORA",
        addressing_mode: AddressingMode::Absolute,
        cycles: 4,
    },
    // Opcode: 0x0E
    OpCode {
        execute: CPU::asl,
        addressing: CPU::absolute,
        name: "ASL",
        addressing_mode: AddressingMode::Absolute,
        cycles: 6,
    },
    // Opcode: 0x0F
    OpCode {
        execute: CPU::slo,
        addressing: CPU::absolute,
        name: "SLO",
        addressing_mode: AddressingMode::Absolute,
        cycles: 6,
    },
    // Opcode: 0x10
    OpCode {
        execute: CPU::bpl,
        addressing: CPU::relative,
        name: "BPL",
        addressing_mode: AddressingMode::Relative,
        cycles: 2,
    },
    // Opcode: 0x11
    OpCode {
        execute: CPU::ora,
        addressing: CPU::indirect_y,
        name: "ORA",
        addressing_mode: AddressingMode::IndirectY,
        cycles: 5,
    },
    // Opcode: 0x11
    OpCode {
        execute: CPU::ora,
        addressing: CPU::indirect_y,
        name: "ORA",
        addressing_mode: AddressingMode::IndirectY,
        cycles: 5,
    },
    // Opcode: 0x13
    OpCode {
        execute: CPU::slo,
        addressing: CPU::indirect_y,
        name: "SLO",
        addressing_mode: AddressingMode::IndirectY,
        cycles: 8,
    },
    // Opcode: 0x14
    OpCode {
        execute: CPU::nop,
        addressing: CPU::zero_page_x,
        name: "NOP",
        addressing_mode: AddressingMode::ZeroPageX,
        cycles: 4,
    },
    // Opcode: 0x15
    OpCode {
        execute: CPU::ora,
        addressing: CPU::zero_page_x,
        name: "ORA",
        addressing_mode: AddressingMode::ZeroPageX,
        cycles: 4,
    },
    // Opcode: 0x16
    OpCode {
        execute: CPU::asl,
        addressing: CPU::zero_page_x,
        name: "ASL",
        addressing_mode: AddressingMode::ZeroPageX,
        cycles: 6,
    },
    // Opcode: 0x17
    OpCode {
        execute: CPU::slo,
        addressing: CPU::zero_page_x,
        name: "SLO",
        addressing_mode: AddressingMode::ZeroPageX,
        cycles: 6,
    },
    // Opcode: 0x18
    OpCode {
        execute: CPU::clc,
        addressing: CPU::implied,
        name: "CLC",
        addressing_mode: AddressingMode::Implied,
        cycles: 2,
    },
    // Opcode: 0x19
    OpCode {
        execute: CPU::ora,
        addressing: CPU::absolute_y,
        name: "ORA",
        addressing_mode: AddressingMode::AbsoluteY,
        cycles: 4,
    },
    // Opcode: 0x1A
    OpCode {
        execute: CPU::nop,
        addressing: CPU::implied,
        name: "NOP",
        addressing_mode: AddressingMode::Implied,
        cycles: 2,
    },
    // Opcode: 0x1B
    OpCode {
        execute: CPU::slo,
        addressing: CPU::absolute_y,
        name: "SLO",
        addressing_mode: AddressingMode::AbsoluteY,
        cycles: 7,
    },
    // Opcode: 0x1C
    OpCode {
        execute: CPU::nop,
        addressing: CPU::absolute_x,
        name: "NOP",
        addressing_mode: AddressingMode::AbsoluteX,
        cycles: 4,
    },
    // Opcode: 0x1D
    OpCode {
        execute: CPU::ora,
        addressing: CPU::absolute_x,
        name: "ORA",
        addressing_mode: AddressingMode::AbsoluteX,
        cycles: 4,
    },
    // Opcode: 0x1E
    OpCode {
        execute: CPU::asl,
        addressing: CPU::absolute_x,
        name: "ASL",
        addressing_mode: AddressingMode::AbsoluteX,
        cycles: 7,
    },
    // Opcode: 0x1F
    OpCode {
        execute: CPU::slo,
        addressing: CPU::absolute_x,
        name: "SLO",
        addressing_mode: AddressingMode::AbsoluteX,
        cycles: 7,
    },
    // Opcode: 0x20
    OpCode {
        execute: CPU::jsr,
        addressing: CPU::absolute,
        name: "JSR",
        addressing_mode: AddressingMode::Absolute,
        cycles: 6,
    },
    // Opcode: 0x21
    OpCode {
        execute: CPU::and,
        addressing: CPU::indirect_x,
        name: "AND",
        addressing_mode: AddressingMode::IndirectX,
        cycles: 6,
    },
    // Opcode: 0x21
    OpCode {
        execute: CPU::and,
        addressing: CPU::indirect_x,
        name: "AND",
        addressing_mode: AddressingMode::IndirectX,
        cycles: 6,
    },
    // Opcode: 0x23
    OpCode {
        execute: CPU::rla,
        addressing: CPU::indirect_x,
        name: "RLA",
        addressing_mode: AddressingMode::IndirectX,
        cycles: 8,
    },
    // Opcode: 0x24
    OpCode {
        execute: CPU::bit,
        addressing: CPU::zero_page,
        name: "BIT",
        addressing_mode: AddressingMode::ZeroPage,
        cycles: 3,
    },
    // Opcode: 0x25
    OpCode {
        execute: CPU::and,
        addressing: CPU::zero_page,
        name: "AND",
        addressing_mode: AddressingMode::ZeroPage,
        cycles: 3,
    },
    // Opcode: 0x26
    OpCode {
        execute: CPU::rol,
        addressing: CPU::zero_page,
        name: "ROL",
        addressing_mode: AddressingMode::ZeroPage,
        cycles: 5,
    },
    // Opcode: 0x27
    OpCode {
        execute: CPU::rla,
        addressing: CPU::zero_page,
        name: "RLA",
        addressing_mode: AddressingMode::ZeroPage,
        cycles: 5,
    },
    // Opcode: 0x28
    OpCode {
        execute: CPU::plp,
        addressing: CPU::implied,
        name: "PLP",
        addressing_mode: AddressingMode::Implied,
        cycles: 4,
    },
    // Opcode: 0x29
    OpCode {
        execute: CPU::and,
        addressing: CPU::immediate,
        name: "AND",
        addressing_mode: AddressingMode::Immediate,
        cycles: 2,
    },
    // Opcode: 0x2A
    OpCode {
        execute: CPU::rol,
        addressing: CPU::implied,
        name: "ROL",
        addressing_mode: AddressingMode::Implied,
        cycles: 2,
    },
    // Opcode: 0x2B
    OpCode {
        execute: CPU::anc,
        addressing: CPU::immediate,
        name: "ANC",
        addressing_mode: AddressingMode::Immediate,
        cycles: 2,
    },
    // Opcode: 0x2C
    OpCode {
        execute: CPU::bit,
        addressing: CPU::absolute,
        name: "BIT",
        addressing_mode: AddressingMode::Absolute,
        cycles: 4,
    },
    // Opcode: 0x2D
    OpCode {
        execute: CPU::and,
        addressing: CPU::absolute,
        name: "AND",
        addressing_mode: AddressingMode::Absolute,
        cycles: 4,
    },
    // Opcode: 0x2E
    OpCode {
        execute: CPU::rol,
        addressing: CPU::absolute,
        name: "ROL",
        addressing_mode: AddressingMode::Absolute,
        cycles: 6,
    },
    // Opcode: 0x2F
    OpCode {
        execute: CPU::rla,
        addressing: CPU::absolute,
        name: "RLA",
        addressing_mode: AddressingMode::Absolute,
        cycles: 6,
    },
    // Opcode: 0x30
    OpCode {
        execute: CPU::bmi,
        addressing: CPU::relative,
        name: "BMI",
        addressing_mode: AddressingMode::Relative,
        cycles: 2,
    },
    // Opcode: 0x31
    OpCode {
        execute: CPU::and,
        addressing: CPU::indirect_y,
        name: "AND",
        addressing_mode: AddressingMode::IndirectY,
        cycles: 5,
    },
    // Opcode: 0x31
    OpCode {
        execute: CPU::and,
        addressing: CPU::indirect_y,
        name: "AND",
        addressing_mode: AddressingMode::IndirectY,
        cycles: 5,
    },
    // Opcode: 0x33
    OpCode {
        execute: CPU::rla,
        addressing: CPU::indirect_y,
        name: "RLA",
        addressing_mode: AddressingMode::IndirectY,
        cycles: 8,
    },
    // Opcode: 0x34
    OpCode {
        execute: CPU::nop,
        addressing: CPU::zero_page_x,
        name: "NOP",
        addressing_mode: AddressingMode::ZeroPageX,
        cycles: 4,
    },
    // Opcode: 0x35
    OpCode {
        execute: CPU::and,
        addressing: CPU::zero_page_x,
        name: "AND",
        addressing_mode: AddressingMode::ZeroPageX,
        cycles: 4,
    },
    // Opcode: 0x36
    OpCode {
        execute: CPU::rol,
        addressing: CPU::zero_page_x,
        name: "ROL",
        addressing_mode: AddressingMode::ZeroPageX,
        cycles: 6,
    },
    // Opcode: 0x37
    OpCode {
        execute: CPU::rla,
        addressing: CPU::zero_page_x,
        name: "RLA",
        addressing_mode: AddressingMode::ZeroPageX,
        cycles: 6,
    },
    // Opcode: 0x38
    OpCode {
        execute: CPU::sec,
        addressing: CPU::implied,
        name: "SEC",
        addressing_mode: AddressingMode::Implied,
        cycles: 2,
    },
    // Opcode: 0x39
    OpCode {
        execute: CPU::and,
        addressing: CPU::absolute_y,
        name: "AND",
        addressing_mode: AddressingMode::AbsoluteY,
        cycles: 4,
    },
    // Opcode: 0x3A
    OpCode {
        execute: CPU::nop,
        addressing: CPU::implied,
        name: "NOP",
        addressing_mode: AddressingMode::Implied,
        cycles: 2,
    },
    // Opcode: 0x3B
    OpCode {
        execute: CPU::rla,
        addressing: CPU::absolute_y,
        name: "RLA",
        addressing_mode: AddressingMode::AbsoluteY,
        cycles: 7,
    },
    // Opcode: 0x3C
    OpCode {
        execute: CPU::nop,
        addressing: CPU::absolute_x,
        name: "NOP",
        addressing_mode: AddressingMode::AbsoluteX,
        cycles: 4,
    },
    // Opcode: 0x3D
    OpCode {
        execute: CPU::and,
        addressing: CPU::absolute_x,
        name: "AND",
        addressing_mode: AddressingMode::AbsoluteX,
        cycles: 4,
    },
    // Opcode: 0x3E
    OpCode {
        execute: CPU::rol,
        addressing: CPU::absolute_x,
        name: "ROL",
        addressing_mode: AddressingMode::AbsoluteX,
        cycles: 7,
    },
    // Opcode: 0x3F
    OpCode {
        execute: CPU::rla,
        addressing: CPU::absolute_x,
        name: "RLA",
        addressing_mode: AddressingMode::AbsoluteX,
        cycles: 7,
    },
    // Opcode: 0x40
    OpCode {
        execute: CPU::rti,
        addressing: CPU::implied,
        name: "RTI",
        addressing_mode: AddressingMode::Implied,
        cycles: 6,
    },
    // Opcode: 0x41
    OpCode {
        execute: CPU::eor,
        addressing: CPU::indirect_x,
        name: "EOR",
        addressing_mode: AddressingMode::IndirectX,
        cycles: 6,
    },
    // Opcode: 0x41
    OpCode {
        execute: CPU::eor,
        addressing: CPU::indirect_x,
        name: "EOR",
        addressing_mode: AddressingMode::IndirectX,
        cycles: 6,
    },
    // Opcode: 0x43
    OpCode {
        execute: CPU::sre,
        addressing: CPU::indirect_x,
        name: "SRE",
        addressing_mode: AddressingMode::IndirectX,
        cycles: 8,
    },
    // Opcode: 0x44
    OpCode {
        execute: CPU::nop,
        addressing: CPU::zero_page,
        name: "NOP",
        addressing_mode: AddressingMode::ZeroPage,
        cycles: 3,
    },
    // Opcode: 0x45
    OpCode {
        execute: CPU::eor,
        addressing: CPU::zero_page,
        name: "EOR",
        addressing_mode: AddressingMode::ZeroPage,
        cycles: 3,
    },
    // Opcode: 0x46
    OpCode {
        execute: CPU::lsr,
        addressing: CPU::zero_page,
        name: "LSR",
        addressing_mode: AddressingMode::ZeroPage,
        cycles: 5,
    },
    // Opcode: 0x47
    OpCode {
        execute: CPU::sre,
        addressing: CPU::zero_page,
        name: "SRE",
        addressing_mode: AddressingMode::ZeroPage,
        cycles: 5,
    },
    // Opcode: 0x48
    OpCode {
        execute: CPU::pha,
        addressing: CPU::implied,
        name: "PHA",
        addressing_mode: AddressingMode::Implied,
        cycles: 3,
    },
    // Opcode: 0x49
    OpCode {
        execute: CPU::eor,
        addressing: CPU::immediate,
        name: "EOR",
        addressing_mode: AddressingMode::Immediate,
        cycles: 2,
    },
    // Opcode: 0x4A
    OpCode {
        execute: CPU::lsr,
        addressing: CPU::implied,
        name: "LSR",
        addressing_mode: AddressingMode::Implied,
        cycles: 2,
    },
    // Opcode: 0x4B
    OpCode {
        execute: CPU::alr,
        addressing: CPU::immediate,
        name: "ALR",
        addressing_mode: AddressingMode::Immediate,
        cycles: 2,
    },
    // Opcode: 0x4C
    OpCode {
        execute: CPU::jmp,
        addressing: CPU::absolute,
        name: "JMP",
        addressing_mode: AddressingMode::Absolute,
        cycles: 3,
    },
    // Opcode: 0x4D
    OpCode {
        execute: CPU::eor,
        addressing: CPU::absolute,
        name: "EOR",
        addressing_mode: AddressingMode::Absolute,
        cycles: 4,
    },
    // Opcode: 0x4E
    OpCode {
        execute: CPU::lsr,
        addressing: CPU::absolute,
        name: "LSR",
        addressing_mode: AddressingMode::Absolute,
        cycles: 6,
    },
    // Opcode: 0x4F
    OpCode {
        execute: CPU::sre,
        addressing: CPU::absolute,
        name: "SRE",
        addressing_mode: AddressingMode::Absolute,
        cycles: 6,
    },
    // Opcode: 0x50
    OpCode {
        execute: CPU::bvc,
        addressing: CPU::relative,
        name: "BVC",
        addressing_mode: AddressingMode::Relative,
        cycles: 2,
    },
    // Opcode: 0x51
    OpCode {
        execute: CPU::eor,
        addressing: CPU::indirect_y,
        name: "EOR",
        addressing_mode: AddressingMode::IndirectY,
        cycles: 5,
    },
    // Opcode: 0x51
    OpCode {
        execute: CPU::eor,
        addressing: CPU::indirect_y,
        name: "EOR",
        addressing_mode: AddressingMode::IndirectY,
        cycles: 5,
    },
    // Opcode: 0x53
    OpCode {
        execute: CPU::sre,
        addressing: CPU::indirect_y,
        name: "SRE",
        addressing_mode: AddressingMode::IndirectY,
        cycles: 8,
    },
    // Opcode: 0x54
    OpCode {
        execute: CPU::nop,
        addressing: CPU::zero_page_x,
        name: "NOP",
        addressing_mode: AddressingMode::ZeroPageX,
        cycles: 4,
    },
    // Opcode: 0x55
    OpCode {
        execute: CPU::eor,
        addressing: CPU::zero_page_x,
        name: "EOR",
        addressing_mode: AddressingMode::ZeroPageX,
        cycles: 4,
    },
    // Opcode: 0x56
    OpCode {
        execute: CPU::lsr,
        addressing: CPU::zero_page_x,
        name: "LSR",
        addressing_mode: AddressingMode::ZeroPageX,
        cycles: 6,
    },
    // Opcode: 0x57
    OpCode {
        execute: CPU::sre,
        addressing: CPU::zero_page_x,
        name: "SRE",
        addressing_mode: AddressingMode::ZeroPageX,
        cycles: 6,
    },
    // Opcode: 0x58
    OpCode {
        execute: CPU::cli,
        addressing: CPU::implied,
        name: "CLI",
        addressing_mode: AddressingMode::Implied,
        cycles: 2,
    },
    // Opcode: 0x59
    OpCode {
        execute: CPU::eor,
        addressing: CPU::absolute_y,
        name: "EOR",
        addressing_mode: AddressingMode::AbsoluteY,
        cycles: 4,
    },
    // Opcode: 0x5A
    OpCode {
        execute: CPU::nop,
        addressing: CPU::implied,
        name: "NOP",
        addressing_mode: AddressingMode::Implied,
        cycles: 2,
    },
    // Opcode: 0x5B
    OpCode {
        execute: CPU::sre,
        addressing: CPU::absolute_y,
        name: "SRE",
        addressing_mode: AddressingMode::AbsoluteY,
        cycles: 7,
    },
    // Opcode: 0x5C
    OpCode {
        execute: CPU::nop,
        addressing: CPU::absolute_x,
        name: "NOP",
        addressing_mode: AddressingMode::AbsoluteX,
        cycles: 4,
    },
    // Opcode: 0x5D
    OpCode {
        execute: CPU::eor,
        addressing: CPU::absolute_x,
        name: "EOR",
        addressing_mode: AddressingMode::AbsoluteX,
        cycles: 4,
    },
    // Opcode: 0x5E
    OpCode {
        execute: CPU::lsr,
        addressing: CPU::absolute_x,
        name: "LSR",
        addressing_mode: AddressingMode::AbsoluteX,
        cycles: 7,
    },
    // Opcode: 0x5F
    OpCode {
        execute: CPU::sre,
        addressing: CPU::absolute_x,
        name: "SRE",
        addressing_mode: AddressingMode::AbsoluteX,
        cycles: 7,
    },
    // Opcode: 0x60
    OpCode {
        execute: CPU::rts,
        addressing: CPU::implied,
        name: "RTS",
        addressing_mode: AddressingMode::Implied,
        cycles: 6,
    },
    // Opcode: 0x61
    OpCode {
        execute: CPU::adc,
        addressing: CPU::indirect_x,
        name: "ADC",
        addressing_mode: AddressingMode::IndirectX,
        cycles: 6,
    },
    // Opcode: 0x61
    OpCode {
        execute: CPU::adc,
        addressing: CPU::indirect_x,
        name: "ADC",
        addressing_mode: AddressingMode::IndirectX,
        cycles: 6,
    },
    // Opcode: 0x63
    OpCode {
        execute: CPU::rra,
        addressing: CPU::indirect_x,
        name: "RRA",
        addressing_mode: AddressingMode::IndirectX,
        cycles: 8,
    },
    // Opcode: 0x64
    OpCode {
        execute: CPU::nop,
        addressing: CPU::zero_page,
        name: "NOP",
        addressing_mode: AddressingMode::ZeroPage,
        cycles: 3,
    },
    // Opcode: 0x65
    OpCode {
        execute: CPU::adc,
        addressing: CPU::zero_page,
        name: "ADC",
        addressing_mode: AddressingMode::ZeroPage,
        cycles: 3,
    },
    // Opcode: 0x66
    OpCode {
        execute: CPU::ror,
        addressing: CPU::zero_page,
        name: "ROR",
        addressing_mode: AddressingMode::ZeroPage,
        cycles: 5,
    },
    // Opcode: 0x67
    OpCode {
        execute: CPU::rra,
        addressing: CPU::zero_page,
        name: "RRA",
        addressing_mode: AddressingMode::ZeroPage,
        cycles: 5,
    },
    // Opcode: 0x68
    OpCode {
        execute: CPU::pla,
        addressing: CPU::implied,
        name: "PLA",
        addressing_mode: AddressingMode::Implied,
        cycles: 4,
    },
    // Opcode: 0x69
    OpCode {
        execute: CPU::adc,
        addressing: CPU::immediate,
        name: "ADC",
        addressing_mode: AddressingMode::Immediate,
        cycles: 2,
    },
    // Opcode: 0x6A
    OpCode {
        execute: CPU::ror,
        addressing: CPU::implied,
        name: "ROR",
        addressing_mode: AddressingMode::Implied,
        cycles: 2,
    },
    // Opcode: 0x6B
    OpCode {
        execute: CPU::arr,
        addressing: CPU::immediate,
        name: "ARR",
        addressing_mode: AddressingMode::Immediate,
        cycles: 2,
    },
    // Opcode: 0x6C
    OpCode {
        execute: CPU::jmp,
        addressing: CPU::indirect,
        name: "JMP",
        addressing_mode: AddressingMode::Indirect,
        cycles: 5,
    },
    // Opcode: 0x6D
    OpCode {
        execute: CPU::adc,
        addressing: CPU::absolute,
        name: "ADC",
        addressing_mode: AddressingMode::Absolute,
        cycles: 4,
    },
    // Opcode: 0x6E
    OpCode {
        execute: CPU::ror,
        addressing: CPU::absolute,
        name: "ROR",
        addressing_mode: AddressingMode::Absolute,
        cycles: 6,
    },
    // Opcode: 0x6F
    OpCode {
        execute: CPU::rra,
        addressing: CPU::absolute,
        name: "RRA",
        addressing_mode: AddressingMode::Absolute,
        cycles: 6,
    },
    // Opcode: 0x70
    OpCode {
        execute: CPU::bvs,
        addressing: CPU::relative,
        name: "BVS",
        addressing_mode: AddressingMode::Relative,
        cycles: 2,
    },
    // Opcode: 0x71
    OpCode {
        execute: CPU::adc,
        addressing: CPU::indirect_y,
        name: "ADC",
        addressing_mode: AddressingMode::IndirectY,
        cycles: 5,
    },
    // Opcode: 0x71
    OpCode {
        execute: CPU::adc,
        addressing: CPU::indirect_y,
        name: "ADC",
        addressing_mode: AddressingMode::IndirectY,
        cycles: 5,
    },
    // Opcode: 0x73
    OpCode {
        execute: CPU::rra,
        addressing: CPU::indirect_y,
        name: "RRA",
        addressing_mode: AddressingMode::IndirectY,
        cycles: 8,
    },
    // Opcode: 0x74
    OpCode {
        execute: CPU::nop,
        addressing: CPU::zero_page_x,
        name: "NOP",
        addressing_mode: AddressingMode::ZeroPageX,
        cycles: 4,
    },
    // Opcode: 0x75
    OpCode {
        execute: CPU::adc,
        addressing: CPU::zero_page_x,
        name: "ADC",
        addressing_mode: AddressingMode::ZeroPageX,
        cycles: 4,
    },
    // Opcode: 0x76
    OpCode {
        execute: CPU::ror,
        addressing: CPU::zero_page_x,
        name: "ROR",
        addressing_mode: AddressingMode::ZeroPageX,
        cycles: 6,
    },
    // Opcode: 0x77
    OpCode {
        execute: CPU::rra,
        addressing: CPU::zero_page_x,
        name: "RRA",
        addressing_mode: AddressingMode::ZeroPageX,
        cycles: 6,
    },
    // Opcode: 0x78
    OpCode {
        execute: CPU::sei,
        addressing: CPU::implied,
        name: "SEI",
        addressing_mode: AddressingMode::Implied,
        cycles: 2,
    },
    // Opcode: 0x79
    OpCode {
        execute: CPU::adc,
        addressing: CPU::absolute_y,
        name: "ADC",
        addressing_mode: AddressingMode::AbsoluteY,
        cycles: 4,
    },
    // Opcode: 0x7A
    OpCode {
        execute: CPU::nop,
        addressing: CPU::implied,
        name: "NOP",
        addressing_mode: AddressingMode::Implied,
        cycles: 2,
    },
    // Opcode: 0x7B
    OpCode {
        execute: CPU::rra,
        addressing: CPU::absolute_y,
        name: "RRA",
        addressing_mode: AddressingMode::AbsoluteY,
        cycles: 7,
    },
    // Opcode: 0x7C
    OpCode {
        execute: CPU::nop,
        addressing: CPU::absolute_x,
        name: "NOP",
        addressing_mode: AddressingMode::AbsoluteX,
        cycles: 4,
    },
    // Opcode: 0x7D
    OpCode {
        execute: CPU::adc,
        addressing: CPU::absolute_x,
        name: "ADC",
        addressing_mode: AddressingMode::AbsoluteX,
        cycles: 4,
    },
    // Opcode: 0x7E
    OpCode {
        execute: CPU::ror,
        addressing: CPU::absolute_x,
        name: "ROR",
        addressing_mode: AddressingMode::AbsoluteX,
        cycles: 7,
    },
    // Opcode: 0x7F
    OpCode {
        execute: CPU::rra,
        addressing: CPU::absolute_x,
        name: "RRA",
        addressing_mode: AddressingMode::AbsoluteX,
        cycles: 7,
    },
    // Opcode: 0x80
    OpCode {
        execute: CPU::nop,
        addressing: CPU::immediate,
        name: "NOP",
        addressing_mode: AddressingMode::Immediate,
        cycles: 2,
    },
    // Opcode: 0x81
    OpCode {
        execute: CPU::sta,
        addressing: CPU::indirect_x,
        name: "STA",
        addressing_mode: AddressingMode::IndirectX,
        cycles: 6,
    },
    // Opcode: 0x82
    OpCode {
        execute: CPU::nop,
        addressing: CPU::immediate,
        name: "NOP",
        addressing_mode: AddressingMode::Immediate,
        cycles: 2,
    },
    // Opcode: 0x83
    OpCode {
        execute: CPU::sax,
        addressing: CPU::indirect_x,
        name: "SAX",
        addressing_mode: AddressingMode::IndirectX,
        cycles: 6,
    },
    // Opcode: 0x84
    OpCode {
        execute: CPU::sty,
        addressing: CPU::zero_page,
        name: "STY",
        addressing_mode: AddressingMode::ZeroPage,
        cycles: 3,
    },
    // Opcode: 0x85
    OpCode {
        execute: CPU::sta,
        addressing: CPU::zero_page,
        name: "STA",
        addressing_mode: AddressingMode::ZeroPage,
        cycles: 3,
    },
    // Opcode: 0x86
    OpCode {
        execute: CPU::stx,
        addressing: CPU::zero_page,
        name: "STX",
        addressing_mode: AddressingMode::ZeroPage,
        cycles: 3,
    },
    // Opcode: 0x87
    OpCode {
        execute: CPU::sax,
        addressing: CPU::zero_page,
        name: "SAX",
        addressing_mode: AddressingMode::ZeroPage,
        cycles: 3,
    },
    // Opcode: 0x88
    OpCode {
        execute: CPU::dey,
        addressing: CPU::implied,
        name: "DEY",
        addressing_mode: AddressingMode::Implied,
        cycles: 2,
    },
    // Opcode: 0x89
    OpCode {
        execute: CPU::nop,
        addressing: CPU::immediate,
        name: "NOP",
        addressing_mode: AddressingMode::Immediate,
        cycles: 2,
    },
    // Opcode: 0x8A
    OpCode {
        execute: CPU::txa,
        addressing: CPU::implied,
        name: "TXA",
        addressing_mode: AddressingMode::Implied,
        cycles: 2,
    },
    // Opcode: 0x8B
    OpCode {
        execute: CPU::xaa,
        addressing: CPU::immediate,
        name: "XAA",
        addressing_mode: AddressingMode::Immediate,
        cycles: 2,
    },
    // Opcode: 0x8C
    OpCode {
        execute: CPU::sty,
        addressing: CPU::absolute,
        name: "STY",
        addressing_mode: AddressingMode::Absolute,
        cycles: 4,
    },
    // Opcode: 0x8D
    OpCode {
        execute: CPU::sta,
        addressing: CPU::absolute,
        name: "STA",
        addressing_mode: AddressingMode::Absolute,
        cycles: 4,
    },
    // Opcode: 0x8E
    OpCode {
        execute: CPU::stx,
        addressing: CPU::absolute,
        name: "STX",
        addressing_mode: AddressingMode::Absolute,
        cycles: 4,
    },
    // Opcode: 0x8F
    OpCode {
        execute: CPU::sax,
        addressing: CPU::absolute,
        name: "SAX",
        addressing_mode: AddressingMode::Absolute,
        cycles: 4,
    },
    // Opcode: 0x90
    OpCode {
        execute: CPU::bcc,
        addressing: CPU::relative,
        name: "BCC",
        addressing_mode: AddressingMode::Relative,
        cycles: 2,
    },
    // Opcode: 0x91
    OpCode {
        execute: CPU::sta,
        addressing: CPU::indirect_y,
        name: "STA",
        addressing_mode: AddressingMode::IndirectY,
        cycles: 6,
    },
    // Opcode: 0x91
    OpCode {
        execute: CPU::sta,
        addressing: CPU::indirect_y,
        name: "STA",
        addressing_mode: AddressingMode::IndirectY,
        cycles: 6,
    },
    // Opcode: 0x93
    OpCode {
        execute: CPU::ahx,
        addressing: CPU::indirect_y,
        name: "AHX",
        addressing_mode: AddressingMode::IndirectY,
        cycles: 6,
    },
    // Opcode: 0x94
    OpCode {
        execute: CPU::sty,
        addressing: CPU::zero_page_x,
        name: "STY",
        addressing_mode: AddressingMode::ZeroPageX,
        cycles: 4,
    },
    // Opcode: 0x95
    OpCode {
        execute: CPU::sta,
        addressing: CPU::zero_page_x,
        name: "STA",
        addressing_mode: AddressingMode::ZeroPageX,
        cycles: 4,
    },
    // Opcode: 0x96
    OpCode {
        execute: CPU::stx,
        addressing: CPU::zero_page_y,
        name: "STX",
        addressing_mode: AddressingMode::ZeroPageY,
        cycles: 4,
    },
    // Opcode: 0x97
    OpCode {
        execute: CPU::sax,
        addressing: CPU::zero_page_y,
        name: "SAX",
        addressing_mode: AddressingMode::ZeroPageY,
        cycles: 4,
    },
    // Opcode: 0x98
    OpCode {
        execute: CPU::tya,
        addressing: CPU::implied,
        name: "TYA",
        addressing_mode: AddressingMode::Implied,
        cycles: 2,
    },
    // Opcode: 0x99
    OpCode {
        execute: CPU::sta,
        addressing: CPU::absolute_y,
        name: "STA",
        addressing_mode: AddressingMode::AbsoluteY,
        cycles: 5,
    },
    // Opcode: 0x9A
    OpCode {
        execute: CPU::txs,
        addressing: CPU::implied,
        name: "TXS",
        addressing_mode: AddressingMode::Implied,
        cycles: 2,
    },
    // Opcode: 0x9B
    OpCode {
        execute: CPU::tas,
        addressing: CPU::absolute_y,
        name: "TAS",
        addressing_mode: AddressingMode::AbsoluteY,
        cycles: 5,
    },
    // Opcode: 0x9C
    OpCode {
        execute: CPU::shy,
        addressing: CPU::absolute_x,
        name: "SHY",
        addressing_mode: AddressingMode::AbsoluteX,
        cycles: 5,
    },
    // Opcode: 0x9D
    OpCode {
        execute: CPU::sta,
        addressing: CPU::absolute_x,
        name: "STA",
        addressing_mode: AddressingMode::AbsoluteX,
        cycles: 5,
    },
    // Opcode: 0x9E
    OpCode {
        execute: CPU::shx,
        addressing: CPU::absolute_y,
        name: "SHX",
        addressing_mode: AddressingMode::AbsoluteY,
        cycles: 5,
    },
    // Opcode: 0x9F
    OpCode {
        execute: CPU::ahx,
        addressing: CPU::absolute_y,
        name: "AHX",
        addressing_mode: AddressingMode::AbsoluteY,
        cycles: 5,
    },
    // Opcode: 0xA0
    OpCode {
        execute: CPU::ldy,
        addressing: CPU::immediate,
        name: "LDY",
        addressing_mode: AddressingMode::Immediate,
        cycles: 2,
    },
    // Opcode: 0xA1
    OpCode {
        execute: CPU::lda,
        addressing: CPU::indirect_x,
        name: "LDA",
        addressing_mode: AddressingMode::IndirectX,
        cycles: 6,
    },
    // Opcode: 0xA2
    OpCode {
        execute: CPU::ldx,
        addressing: CPU::immediate,
        name: "LDX",
        addressing_mode: AddressingMode::Immediate,
        cycles: 2,
    },
    // Opcode: 0xA3
    OpCode {
        execute: CPU::lax,
        addressing: CPU::indirect_x,
        name: "LAX",
        addressing_mode: AddressingMode::IndirectX,
        cycles: 6,
    },
    // Opcode: 0xA4
    OpCode {
        execute: CPU::ldy,
        addressing: CPU::zero_page,
        name: "LDY",
        addressing_mode: AddressingMode::ZeroPage,
        cycles: 3,
    },
    // Opcode: 0xA5
    OpCode {
        execute: CPU::lda,
        addressing: CPU::zero_page,
        name: "LDA",
        addressing_mode: AddressingMode::ZeroPage,
        cycles: 3,
    },
    // Opcode: 0xA6
    OpCode {
        execute: CPU::ldx,
        addressing: CPU::zero_page,
        name: "LDX",
        addressing_mode: AddressingMode::ZeroPage,
        cycles: 3,
    },
    // Opcode: 0xA7
    OpCode {
        execute: CPU::lax,
        addressing: CPU::zero_page,
        name: "LAX",
        addressing_mode: AddressingMode::ZeroPage,
        cycles: 3,
    },
    // Opcode: 0xA8
    OpCode {
        execute: CPU::tay,
        addressing: CPU::implied,
        name: "TAY",
        addressing_mode: AddressingMode::Implied,
        cycles: 2,
    },
    // Opcode: 0xA9
    OpCode {
        execute: CPU::lda,
        addressing: CPU::immediate,
        name: "LDA",
        addressing_mode: AddressingMode::Immediate,
        cycles: 2,
    },
    // Opcode: 0xAA
    OpCode {
        execute: CPU::tax,
        addressing: CPU::implied,
        name: "TAX",
        addressing_mode: AddressingMode::Implied,
        cycles: 2,
    },
    // Opcode: 0xAB
    OpCode {
        execute: CPU::lax,
        addressing: CPU::immediate,
        name: "LAX",
        addressing_mode: AddressingMode::Immediate,
        cycles: 2,
    },
    // Opcode: 0xAC
    OpCode {
        execute: CPU::ldy,
        addressing: CPU::absolute,
        name: "LDY",
        addressing_mode: AddressingMode::Absolute,
        cycles: 4,
    },
    // Opcode: 0xAD
    OpCode {
        execute: CPU::lda,
        addressing: CPU::absolute,
        name: "LDA",
        addressing_mode: AddressingMode::Absolute,
        cycles: 4,
    },
    // Opcode: 0xAE
    OpCode {
        execute: CPU::ldx,
        addressing: CPU::absolute,
        name: "LDX",
        addressing_mode: AddressingMode::Absolute,
        cycles: 4,
    },
    // Opcode: 0xAF
    OpCode {
        execute: CPU::lax,
        addressing: CPU::absolute,
        name: "LAX",
        addressing_mode: AddressingMode::Absolute,
        cycles: 4,
    },
    // Opcode: 0xB0
    OpCode {
        execute: CPU::bcs,
        addressing: CPU::relative,
        name: "BCS",
        addressing_mode: AddressingMode::Relative,
        cycles: 2,
    },
    // Opcode: 0xB1
    OpCode {
        execute: CPU::lda,
        addressing: CPU::indirect_y,
        name: "LDA",
        addressing_mode: AddressingMode::IndirectY,
        cycles: 5,
    },
    // Opcode: 0xB1
    OpCode {
        execute: CPU::lda,
        addressing: CPU::indirect_y,
        name: "LDA",
        addressing_mode: AddressingMode::IndirectY,
        cycles: 5,
    },
    // Opcode: 0xB3
    OpCode {
        execute: CPU::lax,
        addressing: CPU::indirect_y,
        name: "LAX",
        addressing_mode: AddressingMode::IndirectY,
        cycles: 5,
    },
    // Opcode: 0xB4
    OpCode {
        execute: CPU::ldy,
        addressing: CPU::zero_page_x,
        name: "LDY",
        addressing_mode: AddressingMode::ZeroPageX,
        cycles: 4,
    },
    // Opcode: 0xB5
    OpCode {
        execute: CPU::lda,
        addressing: CPU::zero_page_x,
        name: "LDA",
        addressing_mode: AddressingMode::ZeroPageX,
        cycles: 4,
    },
    // Opcode: 0xB6
    OpCode {
        execute: CPU::ldx,
        addressing: CPU::zero_page_y,
        name: "LDX",
        addressing_mode: AddressingMode::ZeroPageY,
        cycles: 4,
    },
    // Opcode: 0xB7
    OpCode {
        execute: CPU::lax,
        addressing: CPU::zero_page_y,
        name: "LAX",
        addressing_mode: AddressingMode::ZeroPageY,
        cycles: 4,
    },
    // Opcode: 0xB8
    OpCode {
        execute: CPU::clv,
        addressing: CPU::implied,
        name: "CLV",
        addressing_mode: AddressingMode::Implied,
        cycles: 2,
    },
    // Opcode: 0xB9
    OpCode {
        execute: CPU::lda,
        addressing: CPU::absolute_y,
        name: "LDA",
        addressing_mode: AddressingMode::AbsoluteY,
        cycles: 4,
    },
    // Opcode: 0xBA
    OpCode {
        execute: CPU::tsx,
        addressing: CPU::implied,
        name: "TSX",
        addressing_mode: AddressingMode::Implied,
        cycles: 2,
    },
    // Opcode: 0xBB
    OpCode {
        execute: CPU::las,
        addressing: CPU::absolute_y,
        name: "LAS",
        addressing_mode: AddressingMode::AbsoluteY,
        cycles: 4,
    },
    // Opcode: 0xBC
    OpCode {
        execute: CPU::ldy,
        addressing: CPU::absolute_x,
        name: "LDY",
        addressing_mode: AddressingMode::AbsoluteX,
        cycles: 4,
    },
    // Opcode: 0xBD
    OpCode {
        execute: CPU::lda,
        addressing: CPU::absolute_x,
        name: "LDA",
        addressing_mode: AddressingMode::AbsoluteX,
        cycles: 4,
    },
    // Opcode: 0xBE
    OpCode {
        execute: CPU::ldx,
        addressing: CPU::absolute_y,
        name: "LDX",
        addressing_mode: AddressingMode::AbsoluteY,
        cycles: 4,
    },
    // Opcode: 0xBF
    OpCode {
        execute: CPU::lax,
        addressing: CPU::absolute_y,
        name: "LAX",
        addressing_mode: AddressingMode::AbsoluteY,
        cycles: 4,
    },
    // Opcode: 0xC0
    OpCode {
        execute: CPU::cpy,
        addressing: CPU::immediate,
        name: "CPY",
        addressing_mode: AddressingMode::Immediate,
        cycles: 2,
    },
    // Opcode: 0xC1
    OpCode {
        execute: CPU::cmp,
        addressing: CPU::indirect_x,
        name: "CMP",
        addressing_mode: AddressingMode::IndirectX,
        cycles: 6,
    },
    // Opcode: 0xC2
    OpCode {
        execute: CPU::nop,
        addressing: CPU::immediate,
        name: "NOP",
        addressing_mode: AddressingMode::Immediate,
        cycles: 2,
    },
    // Opcode: 0xC3
    OpCode {
        execute: CPU::dcp,
        addressing: CPU::indirect_x,
        name: "DCP",
        addressing_mode: AddressingMode::IndirectX,
        cycles: 8,
    },
    // Opcode: 0xC4
    OpCode {
        execute: CPU::cpy,
        addressing: CPU::zero_page,
        name: "CPY",
        addressing_mode: AddressingMode::ZeroPage,
        cycles: 3,
    },
    // Opcode: 0xC5
    OpCode {
        execute: CPU::cmp,
        addressing: CPU::zero_page,
        name: "CMP",
        addressing_mode: AddressingMode::ZeroPage,
        cycles: 3,
    },
    // Opcode: 0xC6
    OpCode {
        execute: CPU::dec,
        addressing: CPU::zero_page,
        name: "DEC",
        addressing_mode: AddressingMode::ZeroPage,
        cycles: 5,
    },
    // Opcode: 0xC7
    OpCode {
        execute: CPU::dcp,
        addressing: CPU::zero_page,
        name: "DCP",
        addressing_mode: AddressingMode::ZeroPage,
        cycles: 5,
    },
    // Opcode: 0xC8
    OpCode {
        execute: CPU::iny,
        addressing: CPU::implied,
        name: "INY",
        addressing_mode: AddressingMode::Implied,
        cycles: 2,
    },
    // Opcode: 0xC9
    OpCode {
        execute: CPU::cmp,
        addressing: CPU::immediate,
        name: "CMP",
        addressing_mode: AddressingMode::Immediate,
        cycles: 2,
    },
    // Opcode: 0xCA
    OpCode {
        execute: CPU::dex,
        addressing: CPU::implied,
        name: "DEX",
        addressing_mode: AddressingMode::Implied,
        cycles: 2,
    },
    // Opcode: 0xCB
    OpCode {
        execute: CPU::axs,
        addressing: CPU::immediate,
        name: "AXS",
        addressing_mode: AddressingMode::Immediate,
        cycles: 2,
    },
    // Opcode: 0xCC
    OpCode {
        execute: CPU::cpy,
        addressing: CPU::absolute,
        name: "CPY",
        addressing_mode: AddressingMode::Absolute,
        cycles: 4,
    },
    // Opcode: 0xCD
    OpCode {
        execute: CPU::cmp,
        addressing: CPU::absolute,
        name: "CMP",
        addressing_mode: AddressingMode::Absolute,
        cycles: 4,
    },
    // Opcode: 0xCE
    OpCode {
        execute: CPU::dec,
        addressing: CPU::absolute,
        name: "DEC",
        addressing_mode: AddressingMode::Absolute,
        cycles: 6,
    },
    // Opcode: 0xCF
    OpCode {
        execute: CPU::dcp,
        addressing: CPU::absolute,
        name: "DCP",
        addressing_mode: AddressingMode::Absolute,
        cycles: 6,
    },
    // Opcode: 0xD0
    OpCode {
        execute: CPU::bne,
        addressing: CPU::relative,
        name: "BNE",
        addressing_mode: AddressingMode::Relative,
        cycles: 2,
    },
    // Opcode: 0xD1
    OpCode {
        execute: CPU::cmp,
        addressing: CPU::indirect_y,
        name: "CMP",
        addressing_mode: AddressingMode::IndirectY,
        cycles: 5,
    },
    // Opcode: 0xD1
    OpCode {
        execute: CPU::cmp,
        addressing: CPU::indirect_y,
        name: "CMP",
        addressing_mode: AddressingMode::IndirectY,
        cycles: 5,
    },
    // Opcode: 0xD3
    OpCode {
        execute: CPU::dcp,
        addressing: CPU::indirect_y,
        name: "DCP",
        addressing_mode: AddressingMode::IndirectY,
        cycles: 8,
    },
    // Opcode: 0xD4
    OpCode {
        execute: CPU::nop,
        addressing: CPU::zero_page_x,
        name: "NOP",
        addressing_mode: AddressingMode::ZeroPageX,
        cycles: 4,
    },
    // Opcode: 0xD5
    OpCode {
        execute: CPU::cmp,
        addressing: CPU::zero_page_x,
        name: "CMP",
        addressing_mode: AddressingMode::ZeroPageX,
        cycles: 4,
    },
    // Opcode: 0xD6
    OpCode {
        execute: CPU::dec,
        addressing: CPU::zero_page_x,
        name: "DEC",
        addressing_mode: AddressingMode::ZeroPageX,
        cycles: 6,
    },
    // Opcode: 0xD7
    OpCode {
        execute: CPU::dcp,
        addressing: CPU::zero_page_x,
        name: "DCP",
        addressing_mode: AddressingMode::ZeroPageX,
        cycles: 6,
    },
    // Opcode: 0xD8
    OpCode {
        execute: CPU::cld,
        addressing: CPU::implied,
        name: "CLD",
        addressing_mode: AddressingMode::Implied,
        cycles: 2,
    },
    // Opcode: 0xD9
    OpCode {
        execute: CPU::cmp,
        addressing: CPU::absolute_y,
        name: "CMP",
        addressing_mode: AddressingMode::AbsoluteY,
        cycles: 4,
    },
    // Opcode: 0xDA
    OpCode {
        execute: CPU::nop,
        addressing: CPU::implied,
        name: "NOP",
        addressing_mode: AddressingMode::Implied,
        cycles: 2,
    },
    // Opcode: 0xDB
    OpCode {
        execute: CPU::dcp,
        addressing: CPU::absolute_y,
        name: "DCP",
        addressing_mode: AddressingMode::AbsoluteY,
        cycles: 7,
    },
    // Opcode: 0xDC
    OpCode {
        execute: CPU::nop,
        addressing: CPU::absolute_x,
        name: "NOP",
        addressing_mode: AddressingMode::AbsoluteX,
        cycles: 4,
    },
    // Opcode: 0xDD
    OpCode {
        execute: CPU::cmp,
        addressing: CPU::absolute_x,
        name: "CMP",
        addressing_mode: AddressingMode::AbsoluteX,
        cycles: 4,
    },
    // Opcode: 0xDE
    OpCode {
        execute: CPU::dec,
        addressing: CPU::absolute_x,
        name: "DEC",
        addressing_mode: AddressingMode::AbsoluteX,
        cycles: 7,
    },
    // Opcode: 0xDF
    OpCode {
        execute: CPU::dcp,
        addressing: CPU::absolute_x,
        name: "DCP",
        addressing_mode: AddressingMode::AbsoluteX,
        cycles: 7,
    },
    // Opcode: 0xE0
    OpCode {
        execute: CPU::cpx,
        addressing: CPU::immediate,
        name: "CPX",
        addressing_mode: AddressingMode::Immediate,
        cycles: 2,
    },
    // Opcode: 0xE1
    OpCode {
        execute: CPU::sbc,
        addressing: CPU::indirect_x,
        name: "SBC",
        addressing_mode: AddressingMode::IndirectX,
        cycles: 6,
    },
    // Opcode: 0xE2
    OpCode {
        execute: CPU::nop,
        addressing: CPU::immediate,
        name: "NOP",
        addressing_mode: AddressingMode::Immediate,
        cycles: 2,
    },
    // Opcode: 0xE3
    OpCode {
        execute: CPU::isc,
        addressing: CPU::indirect_x,
        name: "ISC",
        addressing_mode: AddressingMode::IndirectX,
        cycles: 8,
    },
    // Opcode: 0xE4
    OpCode {
        execute: CPU::cpx,
        addressing: CPU::zero_page,
        name: "CPX",
        addressing_mode: AddressingMode::ZeroPage,
        cycles: 3,
    },
    // Opcode: 0xE5
    OpCode {
        execute: CPU::sbc,
        addressing: CPU::zero_page,
        name: "SBC",
        addressing_mode: AddressingMode::ZeroPage,
        cycles: 3,
    },
    // Opcode: 0xE6
    OpCode {
        execute: CPU::inc,
        addressing: CPU::zero_page,
        name: "INC",
        addressing_mode: AddressingMode::ZeroPage,
        cycles: 5,
    },
    // Opcode: 0xE7
    OpCode {
        execute: CPU::isc,
        addressing: CPU::zero_page,
        name: "ISC",
        addressing_mode: AddressingMode::ZeroPage,
        cycles: 5,
    },
    // Opcode: 0xE8
    OpCode {
        execute: CPU::inx,
        addressing: CPU::implied,
        name: "INX",
        addressing_mode: AddressingMode::Implied,
        cycles: 2,
    },
    // Opcode: 0xE9
    OpCode {
        execute: CPU::sbc,
        addressing: CPU::immediate,
        name: "SBC",
        addressing_mode: AddressingMode::Immediate,
        cycles: 2,
    },
    // Opcode: 0xEA
    OpCode {
        execute: CPU::nop,
        addressing: CPU::implied,
        name: "NOP",
        addressing_mode: AddressingMode::Implied,
        cycles: 2,
    },
    // Opcode: 0xEB
    OpCode {
        execute: CPU::sbc,
        addressing: CPU::immediate,
        name: "SBC",
        addressing_mode: AddressingMode::Immediate,
        cycles: 2,
    },
    // Opcode: 0xEC
    OpCode {
        execute: CPU::cpx,
        addressing: CPU::absolute,
        name: "CPX",
        addressing_mode: AddressingMode::Absolute,
        cycles: 4,
    },
    // Opcode: 0xED
    OpCode {
        execute: CPU::sbc,
        addressing: CPU::absolute,
        name: "SBC",
        addressing_mode: AddressingMode::Absolute,
        cycles: 4,
    },
    // Opcode: 0xEE
    OpCode {
        execute: CPU::inc,
        addressing: CPU::absolute,
        name: "INC",
        addressing_mode: AddressingMode::Absolute,
        cycles: 6,
    },
    // Opcode: 0xEF
    OpCode {
        execute: CPU::isc,
        addressing: CPU::absolute,
        name: "ISC",
        addressing_mode: AddressingMode::Absolute,
        cycles: 6,
    },
    // Opcode: 0xF0
    OpCode {
        execute: CPU::beq,
        addressing: CPU::relative,
        name: "BEQ",
        addressing_mode: AddressingMode::Relative,
        cycles: 2,
    },
    // Opcode: 0xF1
    OpCode {
        execute: CPU::sbc,
        addressing: CPU::indirect_y,
        name: "SBC",
        addressing_mode: AddressingMode::IndirectY,
        cycles: 5,
    },
    // Opcode: 0xF1
    OpCode {
        execute: CPU::sbc,
        addressing: CPU::indirect_y,
        name: "SBC",
        addressing_mode: AddressingMode::IndirectY,
        cycles: 5,
    },
    // Opcode: 0xF3
    OpCode {
        execute: CPU::isc,
        addressing: CPU::indirect_y,
        name: "ISC",
        addressing_mode: AddressingMode::IndirectY,
        cycles: 8,
    },
    // Opcode: 0xF4
    OpCode {
        execute: CPU::nop,
        addressing: CPU::zero_page_x,
        name: "NOP",
        addressing_mode: AddressingMode::ZeroPageX,
        cycles: 4,
    },
    // Opcode: 0xF5
    OpCode {
        execute: CPU::sbc,
        addressing: CPU::zero_page_x,
        name: "SBC",
        addressing_mode: AddressingMode::ZeroPageX,
        cycles: 4,
    },
    // Opcode: 0xF6
    OpCode {
        execute: CPU::inc,
        addressing: CPU::zero_page_x,
        name: "INC",
        addressing_mode: AddressingMode::ZeroPageX,
        cycles: 6,
    },
    // Opcode: 0xF7
    OpCode {
        execute: CPU::isc,
        addressing: CPU::zero_page_x,
        name: "ISC",
        addressing_mode: AddressingMode::ZeroPageX,
        cycles: 6,
    },
    // Opcode: 0xF8
    OpCode {
        execute: CPU::sed,
        addressing: CPU::implied,
        name: "SED",
        addressing_mode: AddressingMode::Implied,
        cycles: 2,
    },
    // Opcode: 0xF9
    OpCode {
        execute: CPU::sbc,
        addressing: CPU::absolute_y,
        name: "SBC",
        addressing_mode: AddressingMode::AbsoluteY,
        cycles: 4,
    },
    // Opcode: 0xFA
    OpCode {
        execute: CPU::nop,
        addressing: CPU::implied,
        name: "NOP",
        addressing_mode: AddressingMode::Implied,
        cycles: 2,
    },
    // Opcode: 0xFB
    OpCode {
        execute: CPU::isc,
        addressing: CPU::absolute_y,
        name: "ISC",
        addressing_mode: AddressingMode::AbsoluteY,
        cycles: 7,
    },
    // Opcode: 0xFC
    OpCode {
        execute: CPU::nop,
        addressing: CPU::absolute_x,
        name: "NOP",
        addressing_mode: AddressingMode::AbsoluteX,
        cycles: 4,
    },
    // Opcode: 0xFD
    OpCode {
        execute: CPU::sbc,
        addressing: CPU::absolute_x,
        name: "SBC",
        addressing_mode: AddressingMode::AbsoluteX,
        cycles: 4,
    },
    // Opcode: 0xFE
    OpCode {
        execute: CPU::inc,
        addressing: CPU::absolute_x,
        name: "INC",
        addressing_mode: AddressingMode::AbsoluteX,
        cycles: 7,
    },
    // Opcode: 0xFF
    OpCode {
        execute: CPU::isc,
        addressing: CPU::absolute_x,
        name: "ISC",
        addressing_mode: AddressingMode::AbsoluteX,
        cycles: 7,
    },
];

bitflags! {
    #[derive(Copy, Clone, Debug)]
    struct StatusFlags: u8 {
        const C = 1;
        const Z = 1 << 1;
        const I = 1 << 2;
        const D = 1 << 3;
        const B = 1 << 4;
        const X = 1 << 5;
        const O = 1 << 6;
        const N = 1 << 7;
    }
}

pub struct CPU {
    accumulator: u8,
    x_register: u8,
    y_register: u8,
    program_counter: u16,
    remaining_cycles: u8,
    pub bus: Box<dyn Bus>,
    status: StatusFlags,
    total_cycles: u64,
    stack_pointer: u8,
}

impl CPU {
    pub fn new(pc: u16, bus: Box<dyn Bus>) -> Self {
        Self {
            accumulator: 0x00,
            x_register: 0x00,
            y_register: 0x00,
            program_counter: pc,
            remaining_cycles: 0,
            total_cycles: 0,
            stack_pointer: 0xfd,
            bus,
            status: StatusFlags::from_bits_truncate(0x24),
        }
    }

    fn cycle(&mut self) {
        if self.remaining_cycles == 0 {
            let opcode = self.bus.read(self.program_counter);

            self.program_counter += 1;

            let op = OPCODE_TABLE[opcode as usize];

            let address = (op.addressing)(self);

            self.program_counter += op.len() - 1;

            (op.execute)(self, address);

            self.remaining_cycles += op.cycles;
        }
        self.total_cycles += 1;
        self.remaining_cycles -= 1;
    }

    pub fn step(&mut self) {
        self.cycle();
        while self.remaining_cycles != 0 {
            self.cycle();
        }
    }

    pub fn run_until_brk(&mut self) {
        while !self.status.contains(StatusFlags::B) {
            self.step()
        }
    }

    fn set_zero_or_neg_flags(&mut self, value: u8) {
        self.status.set(StatusFlags::Z, value == 0);
        self.status
            .set(StatusFlags::N, value & StatusFlags::N.bits() != 0);
    }

    pub fn trace(&self) -> String {
        let opcode = self.bus.read(self.program_counter);

        let op = OPCODE_TABLE[opcode as usize];

        let hexdump = self.hexdump(self.program_counter, self.program_counter + op.len());

        let asm = format!("{}{:28}", op.name, " ");
        let ppu = " ".repeat(11);
        format!(
            "{:04X}  {:9} {} A:{:02X} X:{:02X} Y:{:02X} P:{:02X} SP:{:02X} {} CYC:{}",
            self.program_counter,
            hexdump,
            asm,
            self.accumulator,
            self.x_register,
            self.y_register,
            self.status.bits(),
            self.stack_pointer,
            ppu,
            self.total_cycles + 7
        ) // TODO figure this out
    }

    // TODO: consider if this should be in the Bus trait instead
    fn hexdump(&self, start: u16, end: u16) -> String {
        let mut hexdump = String::new();
        for addr in start..end {
            hexdump.push_str(&format!("{:02X} ", self.bus.read(addr)));
        }
        hexdump
    }
}

fn s8_to_u16(value: u8) -> u16 {
    let mut value = u16::from(value);
    if value & 0x80 > 0 {
        value |= 0xff00;
    }
    return value;
}

const STACK_PAGE: u16 = 0x0100;

// Operations
impl CPU {
    fn adc(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Absolute(address) => {
            let value = self.bus.read(address);
            let carry = self.status.contains(StatusFlags::C) as u16;
            let result: u16 = u16::from(self.accumulator) + u16::from(value) + carry;
            let result_u8 = result as u8;

            self.status.set(StatusFlags::C, result > u16::from(u8::max_value()));
            self.status.set(
                StatusFlags::O,
                (!(self.accumulator ^ value)
                    & (self.accumulator ^ result_u8)
                    & StatusFlags::N.bits())
                    > 0,
            );
            self.set_zero_or_neg_flags(result_u8);

            self.accumulator = result_u8;
        });
    }

    fn ahx(&mut self, _address: Address) {
        todo!("ahx Not Implemented")
    }

    fn alr(&mut self, address: Address) {
        self.and(address);
        self.lsr(Address::Implied);
    }

    fn anc(&mut self, address: Address) {
        self.and(address);
        self.status.set(StatusFlags::C, self.accumulator >> 7 == 1);
    }

    fn and(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Absolute(address) => {
            let value = self.bus.read(address);
            self.accumulator &= value;
            self.set_zero_or_neg_flags(self.accumulator);
        });
    }

    fn arr(&mut self, _address: Address) {
        todo!("arr Not Implemented")
    }

    // TODO: find a way to refactor asl, ror and lsr
    fn asl(&mut self, address: Address) {
        let mut inner = |value: u8| -> u8 {
            self.status.set(StatusFlags::C, value >> 7 == 1);
            let value = value << 1;
            self.status.set(StatusFlags::Z, value == 0);
            self.status
                .set(StatusFlags::N, value & StatusFlags::N.bits() != 0);
            value
        };

        match address {
            Address::Implied => self.accumulator = inner(self.accumulator),
            Address::Absolute(address) => {
                let value = inner(self.bus.read(address));
                self.bus.write(address, value);
            }
            _ => panic!("ASL opcode with relative addressing"),
        }
    }

    fn axs(&mut self, _address: Address) {
        todo!("axs Not Implemented")
    }

    fn branch(&mut self, address: Address, cond: bool) {
        debug_assert_matches!(address,
        Address::Relative(address) => {
            let address = s8_to_u16(address).wrapping_add(self.program_counter);

            if cond {
                if address & 0xff00 != self.program_counter & 0xff00 {
                    self.remaining_cycles += 2;
                } else {
                    self.remaining_cycles += 1;
                }
                self.program_counter = address;
            }
        });
    }

    fn bcc(&mut self, address: Address) {
        self.branch(address, !self.status.contains(StatusFlags::C));
    }

    fn bcs(&mut self, address: Address) {
        self.branch(address, self.status.contains(StatusFlags::C));
    }

    fn beq(&mut self, address: Address) {
        self.branch(address, self.status.contains(StatusFlags::Z));
    }

    fn bit(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Absolute(address) => {
            let value = self.bus.read(address);
            let mask = StatusFlags::from_bits_truncate(value);

            self.status.set(StatusFlags::Z, self.accumulator & value == 0);
            self.status.set(StatusFlags::O, mask.contains(StatusFlags::O));
            self.status.set(StatusFlags::N, mask.contains(StatusFlags::N));
        });
    }

    fn bmi(&mut self, address: Address) {
        self.branch(address, self.status.contains(StatusFlags::N));
    }

    fn bne(&mut self, address: Address) {
        self.branch(address, !self.status.contains(StatusFlags::Z));
    }

    fn bpl(&mut self, address: Address) {
        self.branch(address, !self.status.contains(StatusFlags::N));
    }

    fn brk(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Implied);

        self.status |= StatusFlags::B;
        // TODO: stack manipulation
    }

    fn bvc(&mut self, address: Address) {
        self.branch(address, !self.status.contains(StatusFlags::O));
    }

    fn bvs(&mut self, address: Address) {
        self.branch(address, self.status.contains(StatusFlags::O));
    }

    fn clc(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Implied);
        self.status -= StatusFlags::C;
    }

    fn cld(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Implied);

        self.status -= StatusFlags::D;
    }

    fn cli(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Implied);

        self.status -= StatusFlags::I;
    }

    fn clv(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Implied);

        self.status -= StatusFlags::O;
    }

    fn compare(&mut self, address: Address, register_value: u8) {
        debug_assert_matches!(address, Address::Absolute(address) => {
            let value = self.bus.read(address);

            self.status.set(StatusFlags::C, register_value >= value);

            let cmp = register_value.wrapping_sub(value);
            self.set_zero_or_neg_flags(cmp);
        });
    }

    fn cmp(&mut self, address: Address) {
        self.compare(address, self.accumulator);
    }

    fn cpx(&mut self, address: Address) {
        self.compare(address, self.x_register);
    }

    fn cpy(&mut self, address: Address) {
        self.compare(address, self.y_register);
    }

    fn dcp(&mut self, address: Address) {
        self.dec(address);
        self.cmp(address)
    }

    fn dec(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Absolute(address) => {
            let value = self.bus.read(address).wrapping_sub(1);
            self.set_zero_or_neg_flags(value);
            self.bus.write(address, value);
        });
    }

    fn dex(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Implied);

        self.x_register = self.x_register.wrapping_sub(1);
        self.set_zero_or_neg_flags(self.x_register);
    }

    fn dey(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Implied);

        self.y_register = self.y_register.wrapping_sub(1);
        self.set_zero_or_neg_flags(self.y_register);
    }

    fn eor(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Absolute(address) => {
            let value = self.bus.read(address);
            self.accumulator ^= value;
            self.set_zero_or_neg_flags(self.accumulator);
        });
    }

    fn inc(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Absolute(address) => {
            let value = self.bus.read(address).wrapping_add(1);
            self.set_zero_or_neg_flags(value);
            self.bus.write(address, value);
        });
    }

    fn inx(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Implied);

        self.x_register = self.x_register.wrapping_add(1);
        self.set_zero_or_neg_flags(self.x_register);
    }

    fn iny(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Implied);

        self.y_register = self.y_register.wrapping_add(1);
        self.set_zero_or_neg_flags(self.y_register);
    }

    fn isc(&mut self, address: Address) {
        self.inc(address);
        self.sbc(address);
    }

    fn jmp(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Absolute(address) => self.program_counter = address);
    }

    fn jsr(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Absolute(address) => {
            self.push_stack_16(self.program_counter - 1);
            self.program_counter = address;
        });
    }

    fn las(&mut self, _address: Address) {
        todo!("las Not Implemented")
    }

    fn lax(&mut self, address: Address) {
        self.lda(address);
        self.ldx(address);
    }

    fn lda(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Absolute(address) => {
            self.accumulator = self.bus.read(address);
            self.set_zero_or_neg_flags(self.accumulator);
        });
    }

    fn ldx(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Absolute(address) => {
            self.x_register = self.bus.read(address);
            self.set_zero_or_neg_flags(self.x_register);
        });
    }

    fn ldy(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Absolute(address) => {
            self.y_register = self.bus.read(address);
            self.set_zero_or_neg_flags(self.y_register);
        });
    }

    fn lsr(&mut self, address: Address) {
        let mut inner = |value: u8| -> u8 {
            self.status.set(StatusFlags::C, value & 1 == 1);
            let shifted_value = value >> 1;
            self.status.set(StatusFlags::Z, shifted_value == 0);
            self.status.set(StatusFlags::N, false);
            return shifted_value;
        };

        match address {
            Address::Implied => self.accumulator = inner(self.accumulator),
            Address::Absolute(address) => {
                let value = inner(self.bus.read(address));
                self.bus.write(address, value);
            }
            _ => panic!("LSR opcode with relative addressing"),
        }
    }

    fn nop(&mut self, _address: Address) {
        // Do nothing (NOP)
    }

    fn ora(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Absolute(address) => {
            let value = self.bus.read(address);
            self.accumulator |= value;
            self.set_zero_or_neg_flags(self.accumulator);
        });
    }

    fn pha(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Implied);

        self.push_stack(self.accumulator);
    }

    fn php(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Implied);

        self.push_stack((self.status | StatusFlags::B).bits());
    }

    fn pla(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Implied);

        self.accumulator = self.pop_stack();
        self.set_zero_or_neg_flags(self.accumulator);
    }

    fn plp(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Implied);

        let old_status = self.status;
        let mut new_status = StatusFlags::from_bits_truncate(self.pop_stack());

        new_status.set(StatusFlags::B, old_status.contains(StatusFlags::B));
        new_status.set(StatusFlags::X, old_status.contains(StatusFlags::X));

        self.status = new_status;
    }

    fn rla(&mut self, address: Address) {
        self.rol(address);
        self.and(address);
    }

    fn rol(&mut self, address: Address) {
        let mut inner = |value: u8| -> u8 {
            // Save carry flag
            let carry = if self.status.contains(StatusFlags::C) {
                1
            } else {
                0
            };

            self.status.set(StatusFlags::C, value >> 7 == 1);

            let value = value << 1 | carry;

            self.status.set(StatusFlags::Z, value == 0);
            self.status
                .set(StatusFlags::N, value & StatusFlags::N.bits() != 0);
            value
        };

        match address {
            Address::Implied => self.accumulator = inner(self.accumulator),
            Address::Absolute(address) => {
                let value = inner(self.bus.read(address));
                self.bus.write(address, value);
            }
            _ => panic!("ROR opcode with relative addressing"),
        }
    }

    fn ror(&mut self, address: Address) {
        let mut inner = |value: u8| -> u8 {
            // Save carry flag
            let carry = if self.status.contains(StatusFlags::C) {
                1
            } else {
                0
            };

            self.status.set(StatusFlags::C, value & 1 == 1);

            let value = value >> 1 | carry << 7;

            self.status.set(StatusFlags::Z, value == 0);
            self.status
                .set(StatusFlags::N, value & StatusFlags::N.bits() != 0);
            value
        };

        match address {
            Address::Implied => self.accumulator = inner(self.accumulator),
            Address::Absolute(address) => {
                let value = inner(self.bus.read(address));
                self.bus.write(address, value);
            }
            _ => panic!("ROR opcode with relative addressing"),
        }
    }

    fn rra(&mut self, address: Address) {
        self.ror(address);
        self.adc(address);
    }

    fn rti(&mut self, address: Address) {
        self.plp(address);
        self.program_counter = self.pop_stack_16();
    }

    fn rts(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Implied);

        self.program_counter = self.pop_stack_16() + 1;
    }

    fn sax(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Absolute(address) => self.bus.write(address, self.accumulator & self.x_register));
    }

    fn sbc(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Absolute(address) => {
            let value = self.bus.read(address);
            let carry = self.status.contains(StatusFlags::C) as u16;

            let result = u16::from(self.accumulator) + u16::from(!value) + carry;

            let result_u8 = result as u8;

            self.status.set(StatusFlags::C, result > u16::from(u8::max_value()));
            self.status.set(StatusFlags::Z, result_u8 == 0);
            self.status.set(
                StatusFlags::O,
                ((self.accumulator ^ value)
                    & (self.accumulator ^ result_u8)
                    & StatusFlags::N.bits())
                    > 0,
            );

            self.status.set(StatusFlags::N, result_u8 & StatusFlags::N.bits() > 0);

            self.accumulator = result_u8;
        });
    }

    fn sec(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Implied);

        self.status |= StatusFlags::C;
    }

    fn sed(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Implied);

        self.status |= StatusFlags::D;
    }

    fn sei(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Implied);

        self.status |= StatusFlags::I;
    }

    fn shx(&mut self, _address: Address) {
        todo!("shx Not Implemented")
    }

    fn shy(&mut self, _address: Address) {
        todo!("shy Not Implemented")
    }

    fn slo(&mut self, address: Address) {
        self.asl(address);
        self.ora(address);
    }

    fn sre(&mut self, address: Address) {
        self.lsr(address);
        self.eor(address);
    }

    fn sta(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Absolute(address) => self.bus.write(address, self.accumulator));
    }

    fn stx(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Absolute(address) => self.bus.write(address, self.x_register));
    }

    fn sty(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Absolute(address) => self.bus.write(address, self.y_register));
    }

    fn tas(&mut self, _address: Address) {
        todo!("tas Not Implemented")
    }

    fn tax(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Implied);

        self.x_register = self.accumulator;

        self.set_zero_or_neg_flags(self.x_register);
    }

    fn tay(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Implied);

        self.y_register = self.accumulator;

        self.set_zero_or_neg_flags(self.y_register);
    }

    fn tsx(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Implied);

        self.x_register = self.stack_pointer;
        self.set_zero_or_neg_flags(self.x_register);
    }

    fn txa(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Implied);

        self.accumulator = self.x_register;
        self.set_zero_or_neg_flags(self.x_register);
    }

    fn txs(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Implied);

        self.stack_pointer = self.x_register;
    }

    fn tya(&mut self, address: Address) {
        debug_assert_matches!(address, Address::Implied);

        self.accumulator = self.y_register;
        self.set_zero_or_neg_flags(self.y_register);
    }

    fn xaa(&mut self, _address: Address) {
        todo!("xaa Not Implemented")
    }
}

// Stack manipulation functions
impl CPU {
    fn pop_stack(&mut self) -> u8 {
        self.stack_pointer = self.stack_pointer.wrapping_add(1);
        self.bus.read(STACK_PAGE + u16::from(self.stack_pointer))
    }

    fn pop_stack_16(&mut self) -> u16 {
        let lo = u16::from(self.pop_stack());
        let hi = u16::from(self.pop_stack());
        return (hi << 8) | lo;
    }

    fn push_stack_16(&mut self, data: u16) {
        self.push_stack((data >> 8) as u8);
        self.push_stack(data as u8);
    }

    fn push_stack(&mut self, data: u8) {
        self.bus
            .write(STACK_PAGE + u16::from(self.stack_pointer), data);
        self.stack_pointer = self.stack_pointer.wrapping_sub(1);
    }
}

impl CPU {
    fn implied(&self) -> Address {
        Address::Implied
    }

    fn immediate(&self) -> Address {
        let address = self.program_counter;

        Address::Absolute(address)
    }

    fn zero_page(&self) -> Address {
        let address = u16::from(self.bus.read(self.program_counter));
        Address::Absolute(address)
    }

    fn zero_page_x(&self) -> Address {
        let address = self
            .bus
            .read(self.program_counter)
            .wrapping_add(self.x_register);
        Address::Absolute(u16::from(address))
    }

    fn zero_page_y(&self) -> Address {
        let address = self
            .bus
            .read(self.program_counter)
            .wrapping_add(self.y_register);
        Address::Absolute(u16::from(address))
    }

    fn absolute(&self) -> Address {
        let address = self.bus.read16(self.program_counter);
        Address::Absolute(address)
    }

    fn absolute_x(&self) -> Address {
        let address: u16 = self.bus.read16(self.program_counter);
        let offset_address: u16 = address.wrapping_add(self.x_register as u16);

        Address::Absolute(offset_address)
    }

    fn absolute_y(&self) -> Address {
        let address: u16 = self.bus.read16(self.program_counter);
        let offset_address: u16 = address.wrapping_add(self.y_register as u16);

        Address::Absolute(offset_address)
    }

    fn indirect(&self) -> Address {
        let indirect_address = self.bus.read16(self.program_counter);

        let page = indirect_address & 0xff00;

        let address_hi = u16::from(self.bus.read(page | ((indirect_address + 1) & 0xff))) << 8;
        let address_lo = u16::from(self.bus.read(indirect_address));

        let address = address_hi | address_lo;

        Address::Absolute(address)
    }

    fn indirect_x(&self) -> Address {
        let indirect_address = self
            .bus
            .read(self.program_counter)
            .wrapping_add(self.x_register);
        let indirect_address_plus_one = indirect_address.wrapping_add(1) as u16;

        let address_hi = (self.bus.read(indirect_address_plus_one) as u16) << 8;
        let address_lo = self.bus.read(indirect_address as u16) as u16;

        let address = address_hi | address_lo;

        Address::Absolute(address)
    }

    fn indirect_y(&self) -> Address {
        let indirect_address = self.bus.read(self.program_counter);
        let indirect_address_plus_one = indirect_address.wrapping_add(1) as u16;

        let address_hi = (self.bus.read(indirect_address_plus_one) as u16) << 8;
        let address_lo = self.bus.read(indirect_address as u16) as u16;

        let address = address_hi | address_lo;

        let offset_address = address.wrapping_add(u16::from(self.y_register));

        Address::Absolute(offset_address)
    }

    fn relative(&self) -> Address {
        let relative_address = self.bus.read(self.program_counter);
        Address::Relative(relative_address)
    }
}

#[cfg(test)]
mod tests {

    use super::CPU;

    #[test]
    fn test_simple_program() {
        let program = [
            0xa9, 0x10, // LDA #$10     -> A = #$10
            0x85, 0x20, // STA $20      -> $20 = #$10
            0xa9, 0x01, // LDA #$1      -> A = #$1
            0x65, 0x20, // ADC $20      -> A = #$11
            0x85, 0x21, // STA $21      -> $21=#$11
            0xe6, 0x21, // INC $21      -> $21=#$12
            0xa4, 0x21, // LDY $21      -> Y=#$12
            0xc8, // INY          -> Y=#$13
            0x00, // BRK
        ];

        let mut ram = [0u8; 65536];
        ram[0x0000..program.len()].copy_from_slice(&program);

        let mut cpu = CPU::new(0x00, Box::new(ram));

        // LDA #$10
        cpu.step();

        assert_eq!(cpu.accumulator, 0x10);

        // STA $20
        cpu.step();

        assert_eq!(cpu.bus.read(0x20), 0x10);

        // LDA #$1
        cpu.step();
        assert_eq!(cpu.accumulator, 0x01);

        // ADC $20
        cpu.step();
        assert_eq!(cpu.accumulator, 0x11);

        // STA $21
        cpu.step();
        assert_eq!(cpu.bus.read(0x21), 0x11);

        // INC $21
        cpu.step();
        assert_eq!(cpu.bus.read(0x21), 0x12);

        // LDY $21
        cpu.step();
        assert_eq!(cpu.y_register, 0x12);

        // INY
        cpu.step();
        assert_eq!(cpu.y_register, 0x13);
    }

    #[test]
    fn test_euclid_algo() {
        // From https://github.com/mre/mos6502/blob/master/examples/asm/euclid/euclid.a65
        let program = [
            // .algo
            0xa5, 0x00, // LDA $00
            // .algo_
            0x38, // SEC
            0xe5, 0x01, // SBC $01
            0xf0, 0x07, // BEQ end
            0x30, 0x08, // BMI swap
            0x85, 0x00, // STA $00
            0x4c, 0x12, 0x00, // JMP algo_
            // .end
            0xa5, 0x00, // LDA $00
            0x00, // .swap
            0xa6, 0x00, // LDX $00
            0xa4, 0x01, // LDY $01
            0x86, 0x01, // STX $01
            0x84, 0x00, // STY $00
            0x4c, 0x10, 0x00, // JMP algo
        ];

        let mut ram = [0u8; 65536];
        ram[0x00] = 30;
        ram[0x01] = 20;
        ram[0x10..0x10 + program.len()].copy_from_slice(&program);

        let mut cpu = CPU::new(0x10, Box::new(ram));

        cpu.run_until_brk();

        assert_eq!(10, cpu.accumulator);
    }
}
